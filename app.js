
    const translations = {
      es: {
        brand_title: "Timer Pro",
        back_menu: "â† Volver al menÃº",
        landing_title: "Elige tu temporizador",
        landing_subtitle: "Selecciona el tipo de entrenamiento que quieres realizar",
        emom_desc: "Every Minute On the Minute - Completa tu trabajo cada minuto",
        tabata_desc: "20s trabajo, 10s descanso - Intervalos de alta intensidad",
        for_time_desc: "Completa el trabajo lo mÃ¡s rÃ¡pido posible",
        amrap_desc: "As Many Rounds As Possible - Tantas rondas como puedas",
        settings: "ConfiguraciÃ³n",
        appearance: "Apariencia",
        theme: "Tema",
        theme_night: "Noche",
        theme_day: "DÃ­a",
        audio_settings: "Audio",
        volume: "Volumen",
        display: "Pantalla",
        keep_screen_on: "Mantener pantalla encendida",
        tab_timer: "CronÃ³metro",
        tab_presets: "Presets",
        tab_history: "Historial",
        new_preset: "Nuevo Preset",
        custom_presets: "Presets Personalizados",
        workout_history: "Historial de Entrenamientos",
        clear_all: "Limpiar Todo",
        export_csv: "Exportar CSV",
        total_workouts: "Entrenamientos Totales",
        total_cycles: "Ciclos Totales",
        ready: "Listo",
        preparing: "Preparandoâ€¦",
        paused: "Pausado",
        start: "Empezar",
        stop: "Detener",
        pause: "Pausar",
        resume: "Continuar",
        reset: "Reiniciar",
        lap: "Lap",
        round: "Round",
        completed_cycles: "Ciclos completados:",
        progress: "Progreso:",
        donate_paypal: "Donar vÃ­a PayPal",
        cancel: "Cancelar",
        save: "Guardar",
        skip: "Omitir",
        save_notes: "Guardar Notas",
        workout_complete: "ğŸ‰ Â¡Entrenamiento Completado!",
        share_result: "Compartir Resultado",
        add_notes: "Agregar Notas",
        close: "Cerrar",
        edit: "Editar",
        share: "Compartir",
        delete: "Eliminar",
        how_did_it_feel: "Â¿CÃ³mo te sentiste? (RPE, notas, etc.)",
        emom_app_title: "CronÃ³metro EMOM Pro",
        seconds_per_cycle: "Segundos por ciclo:",
        target_cycles: "Ciclos objetivo:",
        leave_empty_unlimited: "(dejar vacÃ­o para ilimitado)",
        training: "Â¡Entrenando!",
        workout_complete_status: "ğŸš¨ Â¡ENTRENAMIENTO COMPLETO! ğŸš¨",
        support_text: "Construido con amor para la comunidad EMOM. Si quieres apoyar mi trabajo, una pequeÃ±a donaciÃ³n ayuda mucho.",
        presets_description: "Crea y gestiona tus presets EMOM personalizados",
        no_presets: "Â¡AÃºn no hay presets personalizados. Haz clic en 'Nuevo Preset' para crear uno!",
        no_history: "Â¡AÃºn no hay entrenamientos completados. Completa un objetivo para ver tu historial aquÃ­!",
        new_preset_title: "Nuevo Preset",
        edit_preset_title: "Editar Preset",
        preset_name: "Nombre del Preset",
        preset_name_placeholder: "ej. EMOM Pesado, Quema RÃ¡pida",
        seconds_per_cycle_short: "Segundos por ciclo",
        target_cycles_short: "Ciclos objetivo",
        optional: "Opcional",
        workout_notes: "Notas del Entrenamiento",
        notes_placeholder: "ej. RPE 8/10, me sentÃ­ fuerte, buena forma durante todo el entrenamiento...",
        tabata_app_title: "CronÃ³metro Tabata Pro",
        support_text_tabata: "Construido con amor para la comunidad Tabata. Si quieres apoyar mi trabajo, una pequeÃ±a donaciÃ³n ayuda mucho.",
        presets_description_tabata: "Crea y gestiona tus presets Tabata personalizados",
        no_presets_tabata: "No hay presets personalizados aÃºn. Â¡Haz clic en 'Nuevo Preset' para crear uno!",
        no_history_tabata: "No hay entrenamientos completados aÃºn. Â¡Completa una sesiÃ³n para ver tu historial aquÃ­!",
        work_seconds: "Trabajo (s):",
        rest_seconds: "Descanso (s):",
        cycles: "Ciclos:",
        work_seconds_short: "Segundos de trabajo",
        rest_seconds_short: "Segundos de descanso",
        new_preset_title_tabata: "Nuevo Preset",
        edit_preset_title_tabata: "Editar Preset",
        preset_name_placeholder_tabata: "ej. Tabata Intenso, Quema Grasa",
        workout_notes_tabata: "Notas del Entrenamiento",
        notes_placeholder_tabata: "ej. RPE 8/10, me sentÃ­ fuerte, buena forma durante todo el entrenamiento...",
        status_work: "Â¡Trabaja!",
        status_rest: "Descansa",
        confirm_delete_preset: "Â¿Eliminar este preset?",
        confirm_delete_history: "Â¿Eliminar este entrenamiento del historial?",
        confirm_clear_history: "Â¿EstÃ¡s seguro de que quieres borrar todo el historial?",
        alert_fill_fields: "Por favor completa todos los campos",
        alert_copied: "Â¡Resultado copiado al portapapeles!",
        share_title_tabata: "Â¡Entrenamiento Tabata Completado!",
        share_text_tabata: "Â¡Tabata Completado! ğŸ’ª\n{cycles} ciclos â€¢ {work}s/{rest}s\n{duration}min entrenamiento el {date}{notes}",
        share_text_emom: "Â¡EMOM Completado! ğŸ’ª\n{cycles} ciclos Ã— {seconds}s\n{duration}min entrenamiento el {date}{notes}",
        minutes_total: "minutos de entrenamiento total",
        fortime_app_title: "CronÃ³metro For Time Pro",
        time_cap: "Time Cap (min):",
        time_cap_minutes: "Time Cap (minutos)",
        new_preset_title_fortime: "Nuevo Preset For Time",
        edit_preset_title_fortime: "Editar Preset For Time",
        preset_name_placeholder_fortime: "ej. Fran, Murph",
        presets_description_fortime: "Crea y gestiona tus presets For Time personalizados.",
        no_presets_fortime: "No hay presets personalizados. Â¡Crea uno!",
        no_history_fortime: "AÃºn no hay entrenamientos. Â¡Completa uno para verlo aquÃ­!",
        workout_notes_fortime: "Notas del Entrenamiento",
        notes_placeholder_fortime: "ej. RPE 9/10, tiempo rÃ©cord, mejorar transiciones...",
        support_text_fortime: "Construido con amor para la comunidad For Time. Si quieres apoyar mi trabajo, una pequeÃ±a donaciÃ³n ayuda mucho.",
        total_laps: "Laps Totales",
        final_time: "Tiempo Final",
        share_title_fortime: "Â¡Entrenamiento For Time Completado!",
        share_text_fortime: "Â¡For Time Completado! ğŸš€\nTiempo: {time}\n{lapsCount} Laps el {date}{timeCapText}{notes}",
        expand_view: "Expandir vista de entrenamiento",
        amrap_app_title: "CronÃ³metro AMRAP Pro",
        workout_duration: "DuraciÃ³n (min):",
        total_rounds: "Rondas Totales",
        completed_rounds: "Rondas completadas:",
        presets_description_amrap: "Crea y gestiona tus presets AMRAP personalizados.",
        no_presets_amrap: "No hay presets personalizados. Â¡Crea uno!",
        no_history_amrap: "AÃºn no hay entrenamientos. Â¡Completa uno para verlo aquÃ­!",
        new_preset_title_amrap: "Nuevo Preset AMRAP",
        edit_preset_title_amrap: "Editar Preset AMRAP",
        preset_name_placeholder_amrap: "ej. Cindy, Chelsea",
        workout_notes_amrap: "Notas del Entrenamiento",
        notes_placeholder_amrap: "ej. RPE 9/10, ritmo constante, mejorar transiciones...",
        support_text_amrap: "Construido con amor para la comunidad AMRAP. Si quieres apoyar mi trabajo, una pequeÃ±a donaciÃ³n ayuda mucho.",
        share_title_amrap: "Â¡Entrenamiento AMRAP Completado! ğŸ”„\n{rounds} Rondas en {duration}min\nel {date}{notes}",
      },
      en: {
        brand_title: "Timer Pro",
        back_menu: "â† Back to menu",
        landing_title: "Choose your timer",
        landing_subtitle: "Select the type of workout you want to perform",
        emom_desc: "Every Minute On the Minute - Complete your work every minute",
        tabata_desc: "20s work, 10s rest - High intensity intervals",
        for_time_desc: "Complete the work as fast as possible",
        amrap_desc: "As Many Rounds As Possible - As many rounds as you can",
        settings: "Settings",
        appearance: "Appearance",
        theme: "Theme",
        theme_night: "Night",
        theme_day: "Day",
        audio_settings: "Audio",
        volume: "Volume",
        display: "Display",
        keep_screen_on: "Keep screen on during workout",
        tab_timer: "Timer",
        tab_presets: "Presets",
        tab_history: "History",
        new_preset: "New Preset",
        custom_presets: "Custom Presets",
        workout_history: "Workout History",
        clear_all: "Clear All",
        export_csv: "Export CSV",
        total_workouts: "Total Workouts",
        total_cycles: "Total Cycles",
        ready: "Ready",
        preparing: "Preparingâ€¦",
        paused: "Paused",
        start: "Start",
        stop: "Stop",
        pause: "Pause",
        resume: "Resume",
        reset: "Reset",
        lap: "Lap",
        round: "Round",
        completed_cycles: "Completed cycles:",
        progress: "Progress:",
        donate_paypal: "Donate via PayPal",
        cancel: "Cancel",
        save: "Save",
        skip: "Skip",
        save_notes: "Save Notes",
        workout_complete: "ğŸ‰ Workout Complete!",
        share_result: "Share Result",
        add_notes: "Add Notes",
        close: "Close",
        edit: "Edit",
        share: "Share",
        delete: "Delete",
        how_did_it_feel: "How did it feel? (RPE, notes, etc.)",
        emom_app_title: "EMOM Timer Pro",
        seconds_per_cycle: "Seconds per cycle:",
        target_cycles: "Target cycles:",
        leave_empty_unlimited: "(leave empty for unlimited)",
        training: "Training!",
        workout_complete_status: "ğŸš¨ WORKOUT COMPLETE! ğŸš¨",
        support_text: "Built with love for the EMOM community. If you want to support my work, a small donation goes a long way.",
        presets_description: "Create and manage your custom EMOM presets",
        no_presets: "No custom presets yet. Click 'New Preset' to create one!",
        no_history: "No completed workouts yet. Complete a target to see your history here!",
        new_preset_title: "New Preset",
        edit_preset_title: "Edit Preset",
        preset_name: "Preset Name",
        preset_name_placeholder: "e.g., Heavy EMOM, Quick Burn",
        seconds_per_cycle_short: "Seconds per cycle",
        target_cycles_short: "Target cycles",
        optional: "Optional",
        workout_notes: "Workout Notes",
        notes_placeholder: "e.g., RPE 8/10, felt strong, good form throughout...",
        tabata_app_title: "Tabata Timer Pro",
        support_text_tabata: "Built with love for the Tabata community. If you want to support my work, a small donation goes a long way.",
        presets_description_tabata: "Create and manage your custom Tabata presets",
        no_presets_tabata: "No custom presets yet. Click 'New Preset' to create one!",
        no_history_tabata: "No completed workouts yet. Complete a session to see your history here!",
        work_seconds: "Work (s):",
        rest_seconds: "Rest (s):",
        cycles: "Cycles:",
        work_seconds_short: "Work seconds",
        rest_seconds_short: "Rest seconds",
        new_preset_title_tabata: "New Preset",
        edit_preset_title_tabata: "Edit Preset",
        preset_name_placeholder_tabata: "e.g., Intense Tabata, Fat Burn",
        workout_notes_tabata: "Workout Notes",
        notes_placeholder_tabata: "e.g., RPE 8/10, felt strong, good form throughout...",
        status_work: "Work!",
        status_rest: "Rest",
        confirm_delete_preset: "Delete this preset?",
        confirm_delete_history: "Delete this workout from history?",
        confirm_clear_history: "Are you sure you want to clear all history?",
        alert_fill_fields: "Please fill all fields",
        alert_copied: "Result copied to clipboard!",
        share_title_tabata: "Tabata Workout Complete!",
        share_text_tabata: "Tabata Completed! ğŸ’ª\n{cycles} cycles â€¢ {work}s/{rest}s\n{duration}min workout on {date}{notes}",
        share_text_emom: "EMOM Completed! ğŸ’ª\n{cycles} cycles Ã— {seconds}s\n{duration}min workout on {date}{notes}",
        minutes_total: "minutes total workout",
        fortime_app_title: "For Time Timer Pro",
        time_cap: "Time Cap (min):",
        time_cap_minutes: "Time Cap (minutes)",
        new_preset_title_fortime: "New For Time Preset",
        edit_preset_title_fortime: "Edit For Time Preset",
        preset_name_placeholder_fortime: "e.g. Fran, Murph",
        presets_description_fortime: "Create and manage your custom For Time presets.",
        no_presets_fortime: "No custom presets yet. Create one!",
        no_history_fortime: "No workouts yet. Complete one to see it here!",
        workout_notes_fortime: "Workout Notes",
        notes_placeholder_fortime: "e.g. RPE 9/10, record time, improve transitions...",
        support_text_fortime: "Built with love for the For Time community. If you want to support my work, a small donation goes a long way.",
        total_laps: "Total Laps",
        final_time: "Final Time",
        share_title_fortime: "For Time Workout Complete!",
        share_text_fortime: "For Time Completed! ğŸš€\nTime: {time}\n{lapsCount} Laps on {date}{timeCapText}{notes}",
        expand_view: "Expand workout view",
        amrap_app_title: "AMRAP Timer Pro",
        workout_duration: "Duration (min):",
        total_rounds: "Total Rounds",
        completed_rounds: "Completed Rounds:",
        presets_description_amrap: "Create and manage your custom AMRAP presets.",
        no_presets_amrap: "No custom presets yet. Create one!",
        no_history_amrap: "No workouts yet. Complete one to see it here!",
        new_preset_title_amrap: "New AMRAP Preset",
        edit_preset_title_amrap: "Edit AMRAP Preset",
        preset_name_placeholder_amrap: "e.g. Cindy, Chelsea",
        workout_notes_amrap: "Workout Notes",
        notes_placeholder_amrap: "e.g. RPE 9/10, consistent pace, improve transitions...",
        support_text_amrap: "Built with love for the AMRAP community. If you want to support my work, a small donation helps a lot.",
        share_title_amrap: "AMRAP Workout Complete!",
        share_text_amrap: "AMRAP Completed! ğŸ”„\n{rounds} Rounds in {duration}min\non {date}{notes}",
      },
      de: {
        brand_title: "Timer Pro",
        back_menu: "â† ZurÃ¼ck zum MenÃ¼",
        landing_title: "WÃ¤hlen Sie Ihren Timer",
        landing_subtitle: "WÃ¤hlen Sie die Art des Trainings, das Sie durchfÃ¼hren mÃ¶chten",
        emom_desc: "Every Minute On the Minute - SchlieÃŸen Sie Ihre Arbeit jede Minute ab",
        tabata_desc: "20s Arbeit, 10s Pause - Hochintensive Intervalle",
        for_time_desc: "SchlieÃŸen Sie die Arbeit so schnell wie mÃ¶glich ab",
        amrap_desc: "As Many Rounds As Possible - So viele Runden wie mÃ¶glich",
        settings: "Einstellungen",
        appearance: "Aussehen",
        theme: "Thema",
        theme_night: "Nacht",
        theme_day: "Tag",
        audio_settings: "Audio",
        volume: "LautstÃ¤rke",
        display: "Anzeige",
        keep_screen_on: "Bildschirm wÃ¤hrend des Trainings eingeschaltet lassen",
        tab_timer: "Timer",
        tab_presets: "Presets",
        tab_history: "Verlauf",
        new_preset: "Neues Preset",
        custom_presets: "Benutzerdefinierte Presets",
        workout_history: "Trainings-Verlauf",
        clear_all: "Alle lÃ¶schen",
        export_csv: "CSV Exportieren",
        total_workouts: "Gesamte Trainings",
        total_cycles: "Gesamte Zyklen",
        ready: "Bereit",
        preparing: "Vorbereitungâ€¦",
        paused: "Pausiert",
        start: "Start",
        stop: "Stopp",
        pause: "Pause",
        resume: "Fortsetzen",
        reset: "ZurÃ¼cksetzen",
        lap: "Runde",
        round: "Runde",
        completed_cycles: "Abgeschlossene Zyklen:",
        progress: "Fortschritt:",
        donate_paypal: "Ãœber PayPal spenden",
        cancel: "Abbrechen",
        save: "Speichern",
        skip: "Ãœberspringen",
        save_notes: "Notizen speichern",
        workout_complete: "ğŸ‰ Training abgeschlossen!",
        share_result: "Ergebnis teilen",
        add_notes: "Notizen hinzufÃ¼gen",
        close: "SchlieÃŸen",
        edit: "Bearbeiten",
        share: "Teilen",
        delete: "LÃ¶schen",
        how_did_it_feel: "Wie hat es sich angefÃ¼hlt? (RPE, Notizen, etc.)",
        emom_app_title: "EMOM Timer Pro",
        seconds_per_cycle: "Sekunden pro Zyklus:",
        target_cycles: "Ziel-Zyklen:",
        leave_empty_unlimited: "(leer lassen fÃ¼r unbegrenzt)",
        training: "Training!",
        workout_complete_status: "ğŸš¨ TRAINING ABGESCHLOSSEN! ğŸš¨",
        support_text: "Mit Liebe fÃ¼r die EMOM-Community erstellt. Wenn Sie meine Arbeit unterstÃ¼tzen mÃ¶chten, hilft eine kleine Spende sehr.",
        presets_description: "Erstellen und verwalten Sie Ihre benutzerdefinierten EMOM-Presets",
        no_presets: "Noch keine benutzerdefinierten Presets. Klicken Sie auf 'Neues Preset', um eines zu erstellen!",
        no_history: "Noch keine abgeschlossenen Trainings. SchlieÃŸen Sie ein Ziel ab, um Ihren Verlauf hier zu sehen!",
        new_preset_title: "Neues Preset",
        edit_preset_title: "Preset bearbeiten",
        preset_name: "Preset-Name",
        preset_name_placeholder: "z.B. Schweres EMOM, Schneller Brand",
        seconds_per_cycle_short: "Sekunden pro Zyklus",
        target_cycles_short: "Ziel-Zyklen",
        optional: "Optional",
        workout_notes: "Trainings-Notizen",
        notes_placeholder: "z.B. RPE 8/10, fÃ¼hlte mich stark, gute Form durchgehend...",
        tabata_app_title: "Tabata Timer Pro",
        support_text_tabata: "Mit Liebe fÃ¼r die Tabata-Community erstellt. Wenn Sie meine Arbeit unterstÃ¼tzen mÃ¶chten, hilft eine kleine Spende sehr.",
        presets_description_tabata: "Erstellen und verwalten Sie Ihre benutzerdefinierten Tabata-Presets",
        no_presets_tabata: "Noch keine benutzerdefinierten Presets. Klicken Sie auf 'Neues Preset', um eines zu erstellen!",
        no_history_tabata: "Noch keine abgeschlossenen Trainings. SchlieÃŸen Sie eine Sitzung ab, um Ihren Verlauf hier zu sehen!",
        work_seconds: "Arbeit (s):",
        rest_seconds: "Pause (s):",
        cycles: "Zyklen:",
        work_seconds_short: "Arbeitssekunden",
        rest_seconds_short: "Pausensekunden",
        new_preset_title_tabata: "Neues Preset",
        edit_preset_title_tabata: "Preset bearbeiten",
        preset_name_placeholder_tabata: "z.B. Intensives Tabata, Fettverbrennung",
        workout_notes_tabata: "Trainings-Notizen",
        notes_placeholder_tabata: "z.B. RPE 8/10, fÃ¼hlte mich stark, gute Form durchgehend...",
        status_work: "Arbeit!",
        status_rest: "Pause",
        confirm_delete_preset: "Dieses Preset lÃ¶schen?",
        confirm_delete_history: "Dieses Training aus dem Verlauf lÃ¶schen?",
        confirm_clear_history: "Sind Sie sicher, dass Sie den gesamten Verlauf lÃ¶schen mÃ¶chten?",
        alert_fill_fields: "Bitte fÃ¼llen Sie alle Felder aus",
        alert_copied: "Ergebnis in die Zwischenablage kopiert!",
        share_title_tabata: "Tabata Training abgeschlossen!",
        share_text_tabata: "Tabata abgeschlossen! ğŸ’ª\n{cycles} Zyklen â€¢ {work}s/{rest}s\n{duration}min Training am {date}{notes}",
        share_text_emom: "EMOM abgeschlossen! ğŸ’ª\n{cycles} Zyklen Ã— {seconds}s\n{duration}min Training am {date}{notes}",
        minutes_total: "Minuten Gesamttraining",
        fortime_app_title: "For Time Timer Pro",
        time_cap: "Zeitlimit (min):",
        time_cap_minutes: "Zeitlimit (Minuten)",
        new_preset_title_fortime: "Neues For Time Preset",
        edit_preset_title_fortime: "For Time Preset bearbeiten",
        preset_name_placeholder_fortime: "z.B. Fran, Murph",
        presets_description_fortime: "Erstellen und verwalten Sie Ihre benutzerdefinierten For Time Presets.",
        no_presets_fortime: "Noch keine Presets. Erstellen Sie eines!",
        no_history_fortime: "Noch keine Trainings. SchlieÃŸen Sie eines ab, um es hier zu sehen!",
        workout_notes_fortime: "Trainingsnotizen",
        notes_placeholder_fortime: "z.B. RPE 9/10, Rekordzeit, ÃœbergÃ¤nge verbessern...",
        support_text_fortime: "Mit Liebe fÃ¼r die For Time-Community erstellt. Wenn Sie meine Arbeit unterstÃ¼tzen mÃ¶chten, hilft eine kleine Spende sehr.",
        total_laps: "Gesamte Runden",
        final_time: "Endzeit",
        share_title_fortime: "For Time Training abgeschlossen!",
        share_text_fortime: "For Time abgeschlossen! ğŸš€\nZeit: {time}\n{lapsCount} Runden am {date}{timeCapText}{notes}",
        expand_view: "Trainingsansicht erweitern",
        amrap_app_title: "AMRAP Timer Pro",
        workout_duration: "Dauer (min):",
        total_rounds: "Gesamte Runden",
        completed_rounds: "Abgeschlossene Runden:",
        presets_description_amrap: "Erstellen und verwalten Sie Ihre benutzerdefinierten AMRAP-Presets.",
        no_presets_amrap: "Noch keine Presets. Erstellen Sie eines!",
        no_history_amrap: "Noch keine Trainings. SchlieÃŸen Sie eines ab, um es hier zu sehen!",
        new_preset_title_amrap: "Neues AMRAP Preset",
        edit_preset_title_amrap: "AMRAP Preset bearbeiten",
        preset_name_placeholder_amrap: "z.B. Cindy, Chelsea",
        workout_notes_amrap: "Trainingsnotizen",
        notes_placeholder_amrap: "z.B. RPE 9/10, konstantes Tempo, ÃœbergÃ¤nge verbessern...",
        support_text_amrap: "Mit Liebe fÃ¼r die AMRAP-Community erstellt. Wenn Sie meine Arbeit unterstÃ¼tzen mÃ¶chten, hilft eine kleine Spende sehr.",
        share_title_amrap: "AMRAP Training abgeschlossen!",
        share_text_amrap: "AMRAP abgeschlossen! ğŸ”„\n{rounds} Runden in {duration}min\nam {date}{notes}",
      },
      fr: {
        brand_title: "Timer Pro",
        back_menu: "â† Retour au menu",
        landing_title: "Choisissez votre minuteur",
        landing_subtitle: "SÃ©lectionnez le type d'entraÃ®nement que vous souhaitez effectuer",
        emom_desc: "Every Minute On the Minute - Terminez votre travail chaque minute",
        tabata_desc: "20s travail, 10s repos - Intervalles haute intensitÃ©",
        for_time_desc: "Terminez le travail le plus rapidement possible",
        amrap_desc: "As Many Rounds As Possible - Autant de tours que possible",
        settings: "ParamÃ¨tres",
        appearance: "Apparence",
        theme: "ThÃ¨me",
        theme_night: "Nuit",
        theme_day: "Jour",
        audio_settings: "Audio",
        volume: "Volume",
        display: "Affichage",
        keep_screen_on: "Garder l'Ã©cran allumÃ© pendant l'entraÃ®nement",
        tab_timer: "Minuteur",
        tab_presets: "PrÃ©rÃ©glages",
        tab_history: "Historique",
        new_preset: "Nouveau PrÃ©rÃ©glage",
        custom_presets: "PrÃ©rÃ©glages PersonnalisÃ©s",
        workout_history: "Historique des EntraÃ®nements",
        clear_all: "Tout effacer",
        export_csv: "Exporter CSV",
        total_workouts: "EntraÃ®nements Totaux",
        total_cycles: "Cycles Totaux",
        ready: "PrÃªt",
        preparing: "PrÃ©parationâ€¦",
        paused: "En pause",
        start: "Commencer",
        stop: "ArrÃªter",
        pause: "Pause",
        resume: "Reprendre",
        reset: "RÃ©initialiser",
        lap: "Tour",
        round: "Round",
        completed_cycles: "Cycles terminÃ©s :",
        progress: "ProgrÃ¨s :",
        donate_paypal: "Faire un don via PayPal",
        cancel: "Annuler",
        save: "Sauvegarder",
        skip: "Ignorer",
        save_notes: "Sauvegarder les Notes",
        workout_complete: "ğŸ‰ EntraÃ®nement TerminÃ© !",
        share_result: "Partager le RÃ©sultat",
        add_notes: "Ajouter des Notes",
        close: "Fermer",
        edit: "Modifier",
        share: "Partager",
        delete: "Supprimer",
        how_did_it_feel: "Comment vous Ãªtes-vous senti ? (RPE, notes, etc.)",
        emom_app_title: "Minuteur EMOM Pro",
        seconds_per_cycle: "Secondes par cycle :",
        target_cycles: "Cycles cibles :",
        leave_empty_unlimited: "(laisser vide pour illimitÃ©)",
        training: "EntraÃ®nement !",
        workout_complete_status: "ğŸš¨ ENTRAÃNEMENT TERMINÃ‰ ! ğŸš¨",
        support_text: "Construit avec amour pour la communautÃ© EMOM. Si vous voulez soutenir mon travail, un petit don aide beaucoup.",
        presets_description: "CrÃ©ez et gÃ©rez vos prÃ©rÃ©glages EMOM personnalisÃ©s",
        no_presets: "Aucun prÃ©rÃ©glage personnalisÃ© pour le moment. Cliquez sur 'Nouveau PrÃ©rÃ©glage' pour en crÃ©er un !",
        no_history: "Aucun entraÃ®nement terminÃ© pour le moment. Terminez un objectif pour voir votre historique ici !",
        new_preset_title: "Nouveau PrÃ©rÃ©glage",
        edit_preset_title: "Modifier le PrÃ©rÃ©glage",
        preset_name: "Nom du PrÃ©rÃ©glage",
        preset_name_placeholder: "ex. EMOM Lourd, BrÃ»lage Rapide",
        seconds_per_cycle_short: "Secondes par cycle",
        target_cycles_short: "Cycles cibles",
        optional: "Optionnel",
        workout_notes: "Notes d'EntraÃ®nement",
        notes_placeholder: "ex. RPE 8/10, je me sentais fort, bonne forme tout au long...",
        tabata_app_title: "Minuteur Tabata Pro",
        support_text_tabata: "Construit avec amour pour la communautÃ© Tabata. Si vous voulez soutenir mon travail, un petit don aide beaucoup.",
        presets_description_tabata: "CrÃ©ez et gÃ©rez vos prÃ©rÃ©glages Tabata personnalisÃ©s",
        no_presets_tabata: "Aucun prÃ©rÃ©glage personnalisÃ© pour le moment. Cliquez sur 'Nouveau PrÃ©rÃ©glage' pour en crÃ©er un !",
        no_history_tabata: "Aucun entraÃ®nement terminÃ© pour le moment. Terminez une session pour voir votre historique ici !",
        work_seconds: "Travail (s) :",
        rest_seconds: "Repos (s) :",
        cycles: "Cycles :",
        work_seconds_short: "Secondes de travail",
        rest_seconds_short: "Secondes de repos",
        new_preset_title_tabata: "Nouveau PrÃ©rÃ©glage",
        edit_preset_title_tabata: "Modifier le PrÃ©rÃ©glage",
        preset_name_placeholder_tabata: "ex. Tabata Intense, BrÃ»le-Graisse",
        workout_notes_tabata: "Notes d'EntraÃ®nement",
        notes_placeholder_tabata: "ex. RPE 8/10, je me sentais fort, bonne forme tout au long...",
        status_work: "Travaillez !",
        status_rest: "Repos",
        confirm_delete_preset: "Supprimer ce prÃ©rÃ©glage ?",
        confirm_delete_history: "Supprimer cet entraÃ®nement de l'historique ?",
        confirm_clear_history: "ÃŠtes-vous sÃ»r de vouloir effacer tout l'historique ?",
        alert_fill_fields: "Veuillez remplir tous les champs",
        alert_copied: "RÃ©sultat copiÃ© dans le presse-papiers !",
        share_title_tabata: "EntraÃ®nement Tabata TerminÃ© !",
        share_text_tabata: "Tabata TerminÃ© ! ğŸ’ª\n{cycles} cycles â€¢ {work}s/{rest}s\n{duration}min d'entraÃ®nement le {date}{notes}",
        share_text_emom: "EMOM TerminÃ© ! ğŸ’ª\n{cycles} cycles Ã— {seconds}s\n{duration}min d'entraÃ®nement le {date}{notes}",
        minutes_total: "minutes d'entraÃ®nement au total",
        fortime_app_title: "Minuteur For Time Pro",
        time_cap: "Temps max (min):",
        time_cap_minutes: "Temps max (minutes)",
        new_preset_title_fortime: "Nouveau PrÃ©rÃ©glage For Time",
        edit_preset_title_fortime: "Modifier PrÃ©rÃ©glage For Time",
        preset_name_placeholder_fortime: "ex. Fran, Murph",
        presets_description_fortime: "CrÃ©ez et gÃ©rez vos prÃ©rÃ©glages For Time personnalisÃ©s.",
        no_presets_fortime: "Aucun prÃ©rÃ©glage. CrÃ©ez-en un !",
        no_history_fortime: "Aucun entraÃ®nement. Terminez-en un pour le voir ici !",
        workout_notes_fortime: "Notes d'entraÃ®nement",
        notes_placeholder_fortime: "ex. RPE 9/10, temps record, amÃ©liorer les transitions...",
        support_text_fortime: "Construit avec amour pour la communautÃ© For Time. Si vous voulez soutenir mon travail, un petit don aide beaucoup.",
        total_laps: "Tours Totaux",
        final_time: "Temps Final",
        share_title_fortime: "EntraÃ®nement For Time TerminÃ© !",
        share_text_fortime: "For Time TerminÃ© ! ğŸš€\nTemps: {time}\n{lapsCount} Tours le {date}{timeCapText}{notes}",
        expand_view: "Agrandir la vue de l'entraÃ®nement",
        amrap_app_title: "Minuteur AMRAP Pro",
        workout_duration: "DurÃ©e (min) :",
        total_rounds: "Tours totaux",
        completed_rounds: "Tours terminÃ©s :",
        presets_description_amrap: "CrÃ©ez et gÃ©rez vos prÃ©rÃ©glages AMRAP personnalisÃ©s.",
        no_presets_amrap: "Aucun prÃ©rÃ©glage pour le moment. CrÃ©ez-en un !",
        no_history_amrap: "Aucun entraÃ®nement pour le moment. Terminez-en un pour le voir ici !",
        new_preset_title_amrap: "Nouveau PrÃ©rÃ©glage AMRAP",
        edit_preset_title_amrap: "Modifier PrÃ©rÃ©glage AMRAP",
        preset_name_placeholder_amrap: "ex: Cindy, Chelsea",
        workout_notes_amrap: "Notes d'entraÃ®nement",
        notes_placeholder_amrap: "ex: RPE 9/10, rythme constant, amÃ©liorer les transitions...",
        support_text_amrap: "Construit avec amour pour la communautÃ© AMRAP. Si vous voulez soutenir mon travail, un petit don est le bienvenu.",
        share_title_amrap: "EntraÃ®nement AMRAP TerminÃ© !",
        share_text_amrap: "AMRAP TerminÃ© ! ğŸ”„\n{rounds} Tours en {duration}min\nle {date}{notes}",
      },
      it: {
        "brand_title": "Timer Pro",
        "back_menu": "â† Torna al menu",
        "landing_title": "Scegli il tuo timer",
        "landing_subtitle": "Seleziona il tipo di allenamento che vuoi eseguire",
        "emom_desc": "Every Minute On the Minute - Completa il tuo lavoro ogni minuto",
        "tabata_desc": "20s lavoro, 10s riposo - Intervalli ad alta intensitÃ ",
        "for_time_desc": "Completa il lavoro il piÃ¹ velocemente possibile",
        "amrap_desc": "As Many Rounds As Possible - Quanti piÃ¹ round possibili",
        "settings": "Impostazioni",
        "appearance": "Aspetto",
        "theme": "Tema",
        "theme_night": "Notte",
        "theme_day": "Giorno",
        "audio_settings": "Audio",
        "volume": "Volume",
        "display": "Schermo",
        "keep_screen_on": "Mantieni lo schermo acceso durante l'allenamento",
        "tab_timer": "Timer",
        "tab_presets": "Preset",
        "tab_history": "Cronologia",
        "new_preset": "Nuovo Preset",
        "custom_presets": "Preset Personalizzati",
        "workout_history": "Cronologia Allenamenti",
        "clear_all": "Cancella Tutto",
        "export_csv": "Esporta CSV",
        "total_workouts": "Allenamenti Totali",
        "total_cycles": "Cicli Totali",
        "ready": "Pronto",
        "preparing": "Preparazioneâ€¦",
        "paused": "In pausa",
        "start": "Inizia",
        "stop": "Ferma",
        "pause": "Pausa",
        "resume": "Riprendi",
        "reset": "Ripristina",
        "lap": "Giro",
        "round": "Round",
        "completed_cycles": "Cicli completati:",
        "progress": "Progresso:",
        "donate_paypal": "Dona tramite PayPal",
        "cancel": "Annulla",
        "save": "Salva",
        "skip": "Salta",
        "save_notes": "Salva Note",
        "workout_complete": "ğŸ‰ Allenamento Completato!",
        "share_result": "Condividi Risultato",
        "add_notes": "Aggiungi Note",
        "close": "Chiudi",
        "edit": "Modifica",
        "share": "Condividi",
        "delete": "Elimina",
        "how_did_it_feel": "Come ti sei sentito? (RPE, note, etc.)",
        "emom_app_title": "Timer EMOM Pro",
        "seconds_per_cycle": "Secondi per ciclo:",
        "target_cycles": "Cicli obiettivo:",
        "leave_empty_unlimited": "(lascia vuoto per illimitato)",
        "training": "Allenamento!",
        "workout_complete_status": "ğŸš¨ ALLENAMENTO COMPLETATO! ğŸš¨",
        "support_text": "Costruito con amore per la comunitÃ  EMOM. Se vuoi supportare il mio lavoro, una piccola donazione aiuta molto.",
        "presets_description": "Crea e gestisci i tuoi preset EMOM personalizzati",
        "no_presets": "Nessun preset personalizzato ancora. Clicca 'Nuovo Preset' per crearne uno!",
        "no_history": "Nessun allenamento completato ancora. Completa un obiettivo per vedere la tua cronologia qui!",
        "new_preset_title": "Nuovo Preset",
        "edit_preset_title": "Modifica Preset",
        "preset_name": "Nome Preset",
        "preset_name_placeholder": "es. EMOM Pesante, Brucia Veloce",
        "seconds_per_cycle_short": "Secondi per ciclo",
        "target_cycles_short": "Cicli obiettivo",
        "optional": "Opzionale",
        "workout_notes": "Note Allenamento",
        "notes_placeholder": "es. RPE 8/10, mi sono sentito forte, buona forma durante tutto...",
        "tabata_app_title": "Timer Tabata Pro",
        "support_text_tabata": "Costruito con amore per la comunitÃ  Tabata. Se vuoi supportare il mio lavoro, una piccola donazione aiuta molto.",
        "presets_description_tabata": "Crea e gestisci i tuoi preset Tabata personalizzati",
        "no_presets_tabata": "Nessun preset personalizzato ancora. Clicca 'Nuovo Preset' per crearne uno!",
        "no_history_tabata": "Nessun allenamento completato ancora. Completa una sessione per vedere la tua cronologia qui!",
        "work_seconds": "Lavoro (s):",
        "rest_seconds": "Riposo (s):",
        "cycles": "Cicli:",
        "work_seconds_short": "Secondi di lavoro",
        "rest_seconds_short": "Secondi di riposo",
        "new_preset_title_tabata": "Nuovo Preset",
        "edit_preset_title_tabata": "Modifica Preset",
        "preset_name_placeholder_tabata": "es. Tabata Intenso, Brucia Grassi",
        "workout_notes_tabata": "Note Allenamento",
        "notes_placeholder_tabata": "es. RPE 8/10, mi sono sentito forte, buona forma durante tutto...",
        "status_work": "Lavora!",
        "status_rest": "Riposo",
        "confirm_delete_preset": "Eliminare questo preset?",
        "confirm_delete_history": "Eliminare questo allenamento dalla cronologia?",
        "confirm_clear_history": "Sei sicuro di voler cancellare tutta la cronologia?",
        "alert_fill_fields": "Per favore, compila tutti i campi",
        "alert_copied": "Risultato copiato negli appunti!",
        "share_title_tabata": "Allenamento Tabata Completato!",
        "share_text_tabata": "Tabata Completato! ğŸ’ª\n{cycles} cicli â€¢ {work}s/{rest}s\n{duration}min allenamento il {date}{notes}",
        "share_text_emom": "EMOM Completato! ğŸ’ª\n{cycles} cicli Ã— {seconds}s\n{duration}min allenamento il {date}{notes}",
        "minutes_total": "minuti di allenamento totale",
        "fortime_app_title": "Timer For Time Pro",
        "time_cap": "Time Cap (min):",
        "time_cap_minutes": "Time Cap (minuti)",
        "new_preset_title_fortime": "Nuovo Preset For Time",
        "edit_preset_title_fortime": "Modifica Preset For Time",
        "preset_name_placeholder_fortime": "es. Fran, Murph",
        "presets_description_fortime": "Crea e gestisci i tuoi preset For Time personalizzati.",
        "no_presets_fortime": "Nessun preset. Creane uno!",
        "no_history_fortime": "Nessun allenamento. Completane uno per vederlo qui!",
        "workout_notes_fortime": "Note Allenamento",
        "notes_placeholder_fortime": "es. RPE 9/10, tempo record, migliorare transizioni...",
        "support_text_fortime": "Costruito con amore per la comunitÃ  For Time. Se vuoi supportare il mio lavoro, una piccola donazione aiuta molto.",
        "total_laps": "Giri Totali",
        "final_time": "Tempo Finale",
        "share_title_fortime": "Allenamento For Time Completato!",
        "share_text_fortime": "For Time Completato! ğŸš€\nTempo: {time}\n{lapsCount} Giri il {date}{timeCapText}{notes}",
        "expand_view": "Espandi la vista allenamento",
        "amrap_app_title": "Timer AMRAP Pro",
        "workout_duration": "Durata (min):",
        "total_rounds": "Round totali",
        "completed_rounds": "Round completati:",
        "presets_description_amrap": "Crea e gestisci i tuoi preset AMRAP personalizzati.",
        "no_presets_amrap": "Nessun preset ancora. Creane uno!",
        "no_history_amrap": "Nessun allenamento ancora. Completane uno per vederlo qui!",
        "new_preset_title_amrap": "Nuovo Preset AMRAP",
        "edit_preset_title_amrap": "Modifica Preset AMRAP",
        "preset_name_placeholder_amrap": "es. Cindy, Chelsea",
        "workout_notes_amrap": "Note allenamento",
        "notes_placeholder_amrap": "es. RPE 9/10, ritmo costante, migliorare le transizioni...",
        "support_text_amrap": "Costruito con amore per la comunitÃ  AMRAP. Se vuoi sostenere il mio lavoro, una piccola donazione aiuta molto.",
        "share_title_amrap": "Allenamento AMRAP completato!",
        "share_text_amrap": "AMRAP completato! ğŸ”„\n{rounds} Round in {duration}min\nil {date}{notes}",
      },
      pt: {
        "brand_title": "Timer Pro",
        "back_menu": "â† Voltar ao menu",
        "landing_title": "Escolha seu cronÃ´metro",
        "landing_subtitle": "Selecione o tipo de treino que deseja realizar",
        "emom_desc": "Every Minute On the Minute - Complete seu trabalho a cada minuto",
        "tabata_desc": "20s trabalho, 10s descanso - Intervalos de alta intensidade",
        "for_time_desc": "Complete o trabalho o mais rÃ¡pido possÃ­vel",
        "amrap_desc": "As Many Rounds As Possible - Quantas rounds conseguir",
        "settings": "ConfiguraÃ§Ãµes",
        "appearance": "AparÃªncia",
        "theme": "Tema",
        "theme_night": "Noite",
        "theme_day": "Dia",
        "audio_settings": "Ãudio",
        "volume": "Volume",
        "display": "Tela",
        "keep_screen_on": "Manter tela ligada durante o treino",
        "tab_timer": "CronÃ´metro",
        "tab_presets": "Presets",
        "tab_history": "HistÃ³rico",
        "new_preset": "Novo Preset",
        "custom_presets": "Presets Personalizados",
        "workout_history": "HistÃ³rico de Treinos",
        "clear_all": "Limpar Tudo",
        "export_csv": "Exportar CSV",
        "total_workouts": "Treinos Totais",
        "total_cycles": "Ciclos Totais",
        "ready": "Pronto",
        "preparing": "Preparandoâ€¦",
        "paused": "Pausado",
        "start": "Iniciar",
        "stop": "Parar",
        "pause": "Pausar",
        "resume": "Continuar",
        "reset": "Reiniciar",
        "lap": "Volta",
        "round": "Round",
        "completed_cycles": "Ciclos completados:",
        "progress": "Progresso:",
        "donate_paypal": "Doar via PayPal",
        "cancel": "Cancelar",
        "save": "Salvar",
        "skip": "Pular",
        "save_notes": "Salvar Notas",
        "workout_complete": "ğŸ‰ Treino ConcluÃ­do!",
        "share_result": "Compartilhar Resultado",
        "add_notes": "Adicionar Notas",
        "close": "Fechar",
        "edit": "Editar",
        "share": "Compartilhar",
        "delete": "Deletar",
        "how_did_it_feel": "Como vocÃª se sentiu? (RPE, notas, etc.)",
        "emom_app_title": "CronÃ³metro EMOM Pro",
        "seconds_per_cycle": "Segundos por ciclo:",
        "target_cycles": "Ciclos alvo:",
        "leave_empty_unlimited": "(deixar vazio para ilimitado)",
        "training": "Treinando!",
        "workout_complete_status": "ğŸš¨ TREINO COMPLETO! ğŸš¨",
        "support_text": "ConstruÃ­do com amor para a comunidade EMOM. Se vocÃª quer apoiar meu trabalho, uma pequena doaÃ§Ã£o ajuda muito.",
        "presets_description": "Crie e gerencie seus presets EMOM personalizados",
        "no_presets": "Nenhum preset personalizado ainda. Clique em 'Novo Preset' para criar um!",
        "no_history": "Nenhum treino completado ainda. Complete um objetivo para ver seu histÃ³rico aqui!",
        "new_preset_title": "Novo Preset",
        "edit_preset_title": "Editar Preset",
        "preset_name": "Nome do Preset",
        "preset_name_placeholder": "ex. EMOM Pesado, Queima RÃ¡pida",
        "seconds_per_cycle_short": "Segundos por ciclo",
        "target_cycles_short": "Ciclos alvo",
        "optional": "Opcional",
        "workout_notes": "Notas do Treino",
        "notes_placeholder": "ex. RPE 8/10, me senti forte, boa forma durante todo...",
        "tabata_app_title": "CronÃ´metro Tabata Pro",
        "support_text_tabata": "ConstruÃ­do com amor para a comunidade Tabata. Se vocÃª quer apoiar meu trabalho, uma pequena doaÃ§Ã£o ajuda muito.",
        "presets_description_tabata": "Crie e gerencie seus presets Tabata personalizados",
        "no_presets_tabata": "Nenhum preset personalizado ainda. Clique em 'Novo Preset' para criar um!",
        "no_history_tabata": "Nenhum treino completado ainda. Complete uma sessÃ£o para ver seu histÃ³rico aqui!",
        "work_seconds": "Trabalho (s):",
        "rest_seconds": "Descanso (s):",
        "cycles": "Ciclos:",
        "work_seconds_short": "Segundos de trabalho",
        "rest_seconds_short": "Segundos de descanso",
        "new_preset_title_tabata": "Novo Preset",
        "edit_preset_title_tabata": "Editar Preset",
        "preset_name_placeholder_tabata": "ex. Tabata Intenso, Queima Gordura",
        "workout_notes_tabata": "Notas do Treino",
        "notes_placeholder_tabata": "ex. RPE 8/10, me senti forte, boa forma durante todo...",
        "status_work": "Trabalhe!",
        "status_rest": "Descanse",
        "confirm_delete_preset": "Deletar este preset?",
        "confirm_delete_history": "Deletar este treino do histÃ³rico?",
        "confirm_clear_history": "Tem certeza que quer limpar todo o histÃ³rico?",
        "alert_fill_fields": "Por favor, preencha todos os campos",
        "alert_copied": "Resultado copiado para a Ã¡rea de transferÃªncia!",
        "share_title_tabata": "Treino de Tabata ConcluÃ­do!",
        "share_text_tabata": "Tabata ConcluÃ­do! ğŸ’ª\n{cycles} ciclos â€¢ {work}s/{rest}s\n{duration}min de treino em {date}{notes}",
        "share_text_emom": "EMOM ConcluÃ­do! ğŸ’ª\n{cycles} ciclos Ã— {seconds}s\n{duration}min de treino em {date}{notes}",
        "minutes_total": "minutos de treino total",
        "fortime_app_title": "CronÃ´metro For Time Pro",
        "time_cap": "Time Cap (min):",
        "time_cap_minutes": "Time Cap (minutos)",
        "new_preset_title_fortime": "Novo Preset For Time",
        "edit_preset_title_fortime": "Editar Preset For Time",
        "preset_name_placeholder_fortime": "ex. Fran, Murph",
        "presets_description_fortime": "Crie e gerencie seus presets For Time personalizados.",
        "no_presets_fortime": "Nenhum preset. Crie um!",
        "no_history_fortime": "Nenhum treino ainda. Complete um para vÃª-lo aqui!",
        "workout_notes_fortime": "Notas do Treino",
        "notes_placeholder_fortime": "ex. RPE 9/10, tempo recorde, mejorar transiÃ§Ãµes...",
        "support_text_fortime": "ConstruÃ­do com amor para la comunidade For Time. Se vocÃª quer apoiar meu trabalho, uma pequena doaÃ§Ã£o ajuda muito.",
        "total_laps": "Voltas Totais",
        "final_time": "Tempo Final",
        "share_title_fortime": "Treino For Time ConcluÃ­do!",
        "share_text_fortime": "For Time ConcluÃ­do! ğŸš€\nTempo: {time}\n{lapsCount} Voltas em {date}{timeCapText}{notes}",
        "expand_view": "Expandir visualizaÃ§Ã£o do treino",
        "amrap_app_title": "CronÃ´metro AMRAP Pro",
        "workout_duration": "DuraÃ§Ã£o (min):",
        "total_rounds": "Rounds Totais",
        "completed_rounds": "Rounds completados:",
        "presets_description_amrap": "Crie e gerencie seus presets AMRAP personalizados.",
        "no_presets_amrap": "Nenhum preset ainda. Crie um!",
        "no_history_amrap": "Nenhum treino ainda. Complete um para vÃª-lo aqui!",
        "new_preset_title_amrap": "Novo Preset AMRAP",
        "edit_preset_title_amrap": "Editar Preset AMRAP",
        "preset_name_placeholder_amrap": "ex. Cindy, Chelsea",
        "workout_notes_amrap": "Notas do Treino",
        "notes_placeholder_amrap": "ex. RPE 9/10, ritmo consistente, melhorar transiÃ§Ãµes...",
        "support_text_amrap": "ConstruÃ­do com amor para a comunidade AMRAP. Se vocÃª quer apoiar meu trabalho, uma pequena doaÃ§Ã£o ajuda muito.",
        "share_title_amrap": "Treino AMRAP ConcluÃ­do!",
        "share_text_amrap": "AMRAP ConcluÃ­do! ğŸ”„\n{rounds} Rounds em {duration}min\nem {date}{notes}",
      },
      zh: {
        "brand_title": "è®¡æ—¶å™¨ä¸“ä¸šç‰ˆ",
        "back_menu": "â† è¿”å›èœå•",
        "landing_title": "é€‰æ‹©æ‚¨çš„è®¡æ—¶å™¨",
        "landing_subtitle": "é€‰æ‹©æ‚¨è¦è¿›è¡Œçš„è®­ç»ƒç±»å‹",
        "emom_desc": "Every Minute On the Minute - æ¯åˆ†é’Ÿå®Œæˆæ‚¨çš„å·¥ä½œ",
        "tabata_desc": "20ç§’å·¥ä½œï¼Œ10ç§’ä¼‘æ¯ - é«˜å¼ºåº¦é—´æ­‡",
        "for_time_desc": "å°½å¿«å®Œæˆå·¥ä½œ",
        "amrap_desc": "As Many Rounds As Possible - å°½å¯èƒ½å¤šçš„è½®æ•°",
        "settings": "è®¾ç½®",
        "appearance": "å¤–è§‚",
        "theme": "ä¸»é¢˜",
        "theme_night": "å¤œé—´",
        "theme_day": "æ—¥é—´",
        "audio_settings": "éŸ³é¢‘",
        "volume": "éŸ³é‡",
        "display": "æ˜¾ç¤º",
        "keep_screen_on": "è®­ç»ƒæ—¶ä¿æŒå±å¹•å¸¸äº®",
        "tab_timer": "è®¡æ—¶å™¨",
        "tab_presets": "é¢„è®¾",
        "tab_history": "å†å²è®°å½•",
        "new_preset": "æ–°é¢„è®¾",
        "custom_presets": "è‡ªå®šä¹‰é¢„è®¾",
        "workout_history": "è®­ç»ƒå†å²",
        "clear_all": "æ¸…ç©ºå…¨éƒ¨",
        "export_csv": "å¯¼å‡º CSV",
        "total_workouts": "æ€»è®­ç»ƒæ¬¡æ•°",
        "total_cycles": "æ€»å¾ªç¯æ•°",
        "ready": "å‡†å¤‡å°±ç»ª",
        "preparing": "å‡†å¤‡ä¸­â€¦",
        "paused": "å·²æš‚åœ",
        "start": "å¼€å§‹",
        "stop": "åœæ­¢",
        "pause": "æš‚åœ",
        "resume": "ç»§ç»­",
        "reset": "é‡ç½®",
        "lap": "è®¡åœˆ",
        "round": "è®¡æ¬¡",
        "completed_cycles": "å·²å®Œæˆå¾ªç¯ï¼š",
        "progress": "è¿›åº¦ï¼š",
        "donate_paypal": "é€šè¿‡ PayPal æèµ ",
        "cancel": "å–æ¶ˆ",
        "save": "ä¿å­˜",
        "skip": "è·³è¿‡",
        "save_notes": "ä¿å­˜å¤‡æ³¨",
        "workout_complete": "ğŸ‰ è®­ç»ƒå®Œæˆï¼",
        "share_result": "åˆ†äº«ç»“æœ",
        "add_notes": "æ·»åŠ å¤‡æ³¨",
        "close": "å…³é—­",
        "edit": "ç¼–è¾‘",
        "share": "åˆ†äº«",
        "delete": "åˆ é™¤",
        "how_did_it_feel": "æ„Ÿè§‰å¦‚ä½•ï¼Ÿï¼ˆRPEã€å¤‡æ³¨ç­‰ï¼‰",
        "emom_app_title": "EMOM è®¡æ—¶å™¨ä¸“ä¸šç‰ˆ",
        "seconds_per_cycle": "æ¯å¾ªç¯ç§’æ•°ï¼š",
        "target_cycles": "ç›®æ ‡å¾ªç¯ï¼š",
        "leave_empty_unlimited": "ï¼ˆç•™ç©ºä¸ºæ— é™åˆ¶ï¼‰",
        "training": "è®­ç»ƒä¸­ï¼",
        "workout_complete_status": "ğŸš¨ è®­ç»ƒå®Œæˆï¼ğŸš¨",
        "support_text": "ä¸º EMOM ç¤¾åŒºç”¨å¿ƒæ‰“é€ ã€‚å¦‚æœæ‚¨æƒ³æ”¯æŒæˆ‘çš„å·¥ä½œï¼Œå°é¢æèµ å°†å¤§æœ‰å¸®åŠ©ã€‚",
        "presets_description": "åˆ›å»ºå’Œç®¡ç†æ‚¨çš„è‡ªå®šä¹‰ EMOM é¢„è®¾",
        "no_presets": "è¿˜æ²¡æœ‰è‡ªå®šä¹‰é¢„è®¾ã€‚ç‚¹å‡»'æ–°é¢„è®¾'åˆ›å»ºä¸€ä¸ªï¼",
        "no_history": "è¿˜æ²¡æœ‰å®Œæˆçš„è®­ç»ƒã€‚å®Œæˆä¸€ä¸ªç›®æ ‡å³å¯åœ¨æ­¤æŸ¥çœ‹æ‚¨çš„å†å²è®°å½•ï¼",
        "new_preset_title": "æ–°é¢„è®¾",
        "edit_preset_title": "ç¼–è¾‘é¢„è®¾",
        "preset_name": "é¢„è®¾åç§°",
        "preset_name_placeholder": "ä¾‹å¦‚ï¼šé‡é‡ EMOMï¼Œå¿«é€Ÿç‡ƒçƒ§",
        "seconds_per_cycle_short": "æ¯å¾ªç¯ç§’æ•°",
        "target_cycles_short": "ç›®æ ‡å¾ªç¯",
        "optional": "å¯é€‰",
        "workout_notes": "è®­ç»ƒå¤‡æ³¨",
        "notes_placeholder": "ä¾‹å¦‚ï¼šRPE 8/10ï¼Œæ„Ÿè§‰å¾ˆå¼ºå£®ï¼Œå…¨ç¨‹åŠ¨ä½œæ ‡å‡†...",
        "tabata_app_title": "Tabata è®¡æ—¶å™¨ä¸“ä¸šç‰ˆ",
        "support_text_tabata": "ä¸º Tabata ç¤¾åŒºç”¨å¿ƒæ‰“é€ ã€‚å¦‚æœæ‚¨æƒ³æ”¯æŒæˆ‘çš„å·¥ä½œï¼Œå°é¢æèµ å°†å¤§æœ‰å¸®åŠ©ã€‚",
        "presets_description_tabata": "åˆ›å»ºå’Œç®¡ç†æ‚¨çš„è‡ªå®šä¹‰ Tabata é¢„è®¾",
        "no_presets_tabata": "è¿˜æ²¡æœ‰è‡ªå®šä¹‰é¢„è®¾ã€‚ç‚¹å‡»'æ–°é¢„è®¾'åˆ›å»ºä¸€ä¸ªï¼",
        "no_history_tabata": "è¿˜æ²¡æœ‰å®Œæˆçš„è®­ç»ƒã€‚å®Œæˆä¸€ä¸ªè®­ç»ƒå³å¯åœ¨æ­¤æŸ¥çœ‹æ‚¨çš„å†å²è®°å½•ï¼",
        "work_seconds": "å·¥ä½œï¼ˆç§’ï¼‰ï¼š",
        "rest_seconds": "ä¼‘æ¯ï¼ˆç§’ï¼‰ï¼š",
        "cycles": "å¾ªç¯ï¼š",
        "work_seconds_short": "å·¥ä½œç§’æ•°",
        "rest_seconds_short": "ä¼‘æ¯ç§’æ•°",
        "new_preset_title_tabata": "æ–°é¢„è®¾",
        "edit_preset_title_tabata": "ç¼–è¾‘é¢„è®¾",
        "preset_name_placeholder_tabata": "ä¾‹å¦‚ï¼šé«˜å¼ºåº¦ Tabataï¼Œç‡ƒè„‚è®­ç»ƒ",
        "workout_notes_tabata": "è®­ç»ƒå¤‡æ³¨",
        "notes_placeholder_tabata": "ä¾‹å¦‚ï¼šRPE 8/10ï¼Œæ„Ÿè§‰å¾ˆå¼ºå£®ï¼Œå…¨ç¨‹åŠ¨ä½œæ ‡å‡†...",
        "status_work": "å¼€å§‹ï¼",
        "status_rest": "ä¼‘æ¯",
        "confirm_delete_preset": "åˆ é™¤æ­¤é¢„è®¾ï¼Ÿ",
        "confirm_delete_history": "ä»å†å²è®°å½•ä¸­åˆ é™¤æ­¤è®­ç»ƒï¼Ÿ",
        "confirm_clear_history": "ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ",
        "alert_fill_fields": "è¯·å¡«å†™æ‰€æœ‰å­—æ®µ",
        "alert_copied": "ç»“æœå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼",
        "share_title_tabata": "Tabata è®­ç»ƒå®Œæˆï¼",
        "share_text_tabata": "Tabata å®Œæˆï¼ğŸ’ª\n{cycles} æ¬¡å¾ªç¯ â€¢ {work}ç§’/{rest}ç§’\n{duration}åˆ†é’Ÿè®­ç»ƒäº {date}{notes}",
        "share_text_emom": "EMOM å®Œæˆï¼ğŸ’ª\n{cycles} æ¬¡å¾ªç¯ Ã— {seconds}ç§’\n{duration}åˆ†é’Ÿè®­ç»ƒäº {date}{notes}",
        "minutes_total": "åˆ†é’Ÿæ€»è®­ç»ƒæ—¶é—´",
        "fortime_app_title": "For Time è®¡æ—¶å™¨ä¸“ä¸šç‰ˆ",
        "time_cap": "æ—¶é—´ä¸Šé™ (åˆ†é’Ÿ):",
        "time_cap_minutes": "æ—¶é—´ä¸Šé™ (åˆ†é’Ÿ)",
        "new_preset_title_fortime": "æ–°å»º For Time é¢„è®¾",
        "edit_preset_title_fortime": "ç¼–è¾‘ For Time é¢„è®¾",
        "preset_name_placeholder_fortime": "ä¾‹å¦‚ï¼šFran, Murph",
        "presets_description_fortime": "åˆ›å»ºå’Œç®¡ç†æ‚¨çš„è‡ªå®šä¹‰ For Time é¢„è®¾ã€‚",
        "no_presets_fortime": "å°šæ— é¢„è®¾ã€‚åˆ›å»ºä¸€ä¸ªå§ï¼",
        "no_history_fortime": "å°šæ— è®­ç»ƒè®°å½•ã€‚å®Œæˆä¸€æ¬¡è®­ç»ƒå³å¯åœ¨æ­¤æŸ¥çœ‹ï¼",
        "workout_notes_fortime": "è®­ç»ƒå¤‡æ³¨",
        "notes_placeholder_fortime": "ä¾‹å¦‚ï¼šRPE 9/10ï¼Œåˆ›ä¸‹çºªå½•ï¼Œæ”¹è¿›è½¬æ¢...",
        "support_text_fortime": "ä¸º For Time ç¤¾åŒºç”¨å¿ƒæ‰“é€ ã€‚å¦‚æœæ‚¨æƒ³æ”¯æŒæˆ‘çš„å·¥ä½œï¼Œå°é¢æèµ å°†å¤§æœ‰å¸®åŠ©ã€‚",
        "total_laps": "æ€»è®¡åœˆæ•°",
        "final_time": "æœ€ç»ˆæ—¶é—´",
        "share_title_fortime": "For Time è®­ç»ƒå®Œæˆï¼",
        "share_text_fortime": "For Time å®Œæˆï¼ğŸš€\næ—¶é—´: {time}\n{lapsCount} åœˆäº {date}{timeCapText}{notes}",
        "expand_view": "å±•å¼€è®­ç»ƒè§†å›¾",
        "amrap_app_title": "AMRAP è®¡æ—¶å™¨ä¸“ä¸šç‰ˆ",
        "workout_duration": "è®­ç»ƒæ—¶é•¿ (åˆ†é’Ÿ):",
        "total_rounds": "æ€»è½®æ•°",
        "completed_rounds": "å·²å®Œæˆè½®æ•°:",
        "presets_description_amrap": "åˆ›å»ºå’Œç®¡ç†æ‚¨çš„è‡ªå®šä¹‰ AMRAP é¢„è®¾ã€‚",
        "no_presets_amrap": "å°šæ— è‡ªå®šä¹‰é¢„è®¾ã€‚åˆ›å»ºä¸€ä¸ªå§ï¼",
        "no_history_amrap": "å°šæ— è®­ç»ƒè®°å½•ã€‚å®Œæˆä¸€æ¬¡å³å¯åœ¨æ­¤æŸ¥çœ‹ï¼",
        "new_preset_title_amrap": "æ–°å»º AMRAP é¢„è®¾",
        "edit_preset_title_amrap": "ç¼–è¾‘ AMRAP é¢„è®¾",
        "preset_name_placeholder_amrap": "ä¾‹å¦‚: Cindy, Chelsea",
        "workout_notes_amrap": "è®­ç»ƒå¤‡æ³¨",
        "notes_placeholder_amrap": "ä¾‹å¦‚: RPE 9/10, èŠ‚å¥ç¨³å®š, æ”¹è¿›è½¬æ¢...",
        "support_text_amrap": "ä¸º AMRAP ç¤¾åŒºç”¨å¿ƒæ‰“é€ ã€‚å¦‚æœæ‚¨æƒ³æ”¯æŒæˆ‘çš„å·¥ä½œï¼Œå°é¢æèµ å°†å¤§æœ‰å¸®åŠ©ã€‚",
        "share_title_amrap": "AMRAP è®­ç»ƒå®Œæˆï¼",
        "share_text_amrap": "AMRAP å®Œæˆï¼ğŸ”„\n{rounds} è½®åœ¨ {duration}åˆ†é’Ÿå†…\näº {date}{notes}",
      }
    };

    // === GLOBAL APP CONTROLLER ===
    let currentLanguage = 'es';
    let wakeLock = null;
    let audioCtx = null;
    let masterGain = null;

    function t(key, replacements = {}) {
      let translation = translations[currentLanguage]?.[key] || translations['en']?.[key] || key;
      for (const placeholder in replacements) {
        translation = translation.replace(`{${placeholder}}`, replacements[placeholder]);
      }
      return translation;
    }

    function translatePage() {
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            const span = el.querySelector('span');
            if (span && el.classList.contains('add-preset')) {
                // Handle complex button like "+ New Preset"
                const textNode = Array.from(el.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
                if(textNode) textNode.textContent = t(key);
                const spanWithText = el.querySelector('span[data-i18n]');
                if (spanWithText) spanWithText.textContent = t(spanWithText.dataset.i18n);

            } else {
               el.textContent = t(key);
            }
        });
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            el.placeholder = t(key);
        });
        document.querySelectorAll('[data-i18n-title]').forEach(el => {
            const key = el.getAttribute('data-i18n-title');
            el.title = t(key);
        });
        const themeOptions = document.querySelectorAll('#themeSelect option');
        themeOptions.forEach(option => {
            const key = option.getAttribute('data-i18n');
            if (key) option.textContent = t(key);
        });
    }

    function updateAllAppsLanguage() {
      translatePage();
      if(EmomApp.initialized) EmomApp.updateLanguage();
      if(TabataApp.initialized) TabataApp.updateLanguage();
      if(ForTimeApp.initialized) ForTimeApp.updateLanguage();
      if(AmrapApp.initialized) AmrapApp.updateLanguage();
    }
    
    function showPage(pageId) {
      document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
      const pageToShow = document.getElementById(pageId);
      if(pageToShow) pageToShow.classList.add('active');
      
      const backBtn = document.getElementById('backBtn');
      const logo = document.querySelector('.header .logo');
      if (pageId === 'home') {
        logo.style.display = 'block';
        backBtn.style.display = 'none';
        if(EmomApp.initialized) EmomApp.resetAll();
        if(TabataApp.initialized) TabataApp.resetAll();
        if(ForTimeApp.initialized) ForTimeApp.resetAll();
        if(AmrapApp.initialized) AmrapApp.resetAll();
      } else {
        logo.style.display = 'none';
        backBtn.style.display = 'flex';
        if (pageId === 'emom') EmomApp.init();
        else if (pageId === 'tabata') TabataApp.init();
        else if (pageId === 'fortime') ForTimeApp.init();
        else if (pageId === 'amrap') AmrapApp.init();
      }
    }

    function openSettings() {
      document.getElementById('settingsModal').classList.add('active');
    }

    function closeSettings() {
      document.getElementById('settingsModal').classList.remove('active');
    }
    
    // === AUDIO SYSTEM ===
    async function ensureAudioContext() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { console.error("AudioContext not supported"); return; }
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume().catch(() => {});
      }
      if (!masterGain && audioCtx) {
        masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);
        const savedVolume = localStorage.getItem('timer_pro_volume');
        masterGain.gain.value = savedVolume !== null ? parseFloat(savedVolume) : 0.8;
      }
      return audioCtx;
    }

    function playTone({ freq = 440, duration = 0.2, type = 'sine', volume = 0.8 }) {
      ensureAudioContext().then(ctx => {
        if(!ctx || !masterGain) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(volume, ctx.currentTime + 0.01);
        gain.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + duration - 0.02);
        osc.connect(gain); gain.connect(masterGain);
        osc.start(); osc.stop(ctx.currentTime + duration + 0.01);
        osc.onended = () => { try { osc.disconnect(); gain.disconnect(); } catch (e) { } };
      }).catch(() => { });
    }

    function playSiren({ startFreq = 800, endFreq = 1400, duration = 0.5, type = 'square', volume = 1.0 }) {
      ensureAudioContext().then(ctx => {
        if(!ctx || !masterGain) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(endFreq, ctx.currentTime + duration);
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(volume, ctx.currentTime + 0.02);
        gain.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + duration - 0.02);
        osc.connect(gain); gain.connect(masterGain);
        osc.start(); osc.stop(ctx.currentTime + duration + 0.01);
        osc.onended = () => { try { osc.disconnect(); gain.disconnect(); } catch (e) { } };
      }).catch(() => { });
    }
    function beepShort() { playTone({ freq: 1000, duration: 0.18, type: 'square', volume: 0.95 }); }
    function beepPrep() { playTone({ freq: 800, duration: 0.22, type: 'sine', volume: 0.95 }); }
    function ring() {
      playTone({ freq: 1200, duration: 0.25, type: 'square', volume: 1.0 });
      setTimeout(() => playTone({ freq: 1200, duration: 0.25, type: 'square', volume: 1.0 }), 300);
      setTimeout(() => playTone({ freq: 1200, duration: 0.4, type: 'square', volume: 1.0 }), 600);
    }
    function victoryBells() {
      let t = 0;
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          playSiren({ startFreq: 600, endFreq: 1200, duration: 0.25, type: 'square', volume: 1.0 });
          playSiren({ startFreq: 700, endFreq: 1400, duration: 0.25, type: 'sawtooth', volume: 0.9 });
        }, t);
        t += 280;
        setTimeout(() => {
          playSiren({ startFreq: 1200, endFreq: 600, duration: 0.25, type: 'square', volume: 1.0 });
          playSiren({ startFreq: 1400, endFreq: 700, duration: 0.25, type: 'sawtooth', volume: 0.9 });
        }, t);
        t += 280;
      }
      setTimeout(() => {
        playSiren({ startFreq: 400, endFreq: 2000, duration: 0.8, type: 'square', volume: 1.0 });
        playSiren({ startFreq: 500, endFreq: 1800, duration: 0.8, type: 'sawtooth', volume: 0.95 });
        setTimeout(() => playTone({ freq: 2400, duration: 0.4, type: 'square', volume: 0.8 }), 200);
      }, t + 200);
    }
    
    // === WAKE LOCK ===
    async function requestWakeLock() {
      if (document.getElementById('wakeLockToggle').classList.contains('active') && 'wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (e) { console.log('WakeLock request failed'); }
      }
    }
    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release().then(() => { wakeLock = null; });
      }
    }

    // === HELPERS ===
    function downloadCSV(csvContent, filename) {
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // === EMOM APP LOGIC ===
    const EmomApp = {
      // State
      cycleSeconds: 60, targetCycles: null, prepInterval: null, running: false,
      paused: false, inPrep: false, remaining: 60, cycles: 0, lastAnnouncedSecond: null,
      startTime: 0, pauseTime: 0, pausedDuration: 0, animationFrameId: null,
      currentWorkout: null, editingPresetIndex: -1, initialized: false, workoutViewActive: false,
      
      // DOM Elements
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.loadSettingsFromLocalStorage();
        this.renderPresets();
        this.loadHistory();
        this.updateUI();
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'secInput', 'targetInput', 'status', 'prep', 'timer', 'startBtn', 'pauseBtn', 'resumeBtn', 'resetBtn', 'cycles', 'progress', 'presetsContainer', 'addPresetBtn', 'quick', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsList', 'historyList', 'totalWorkouts', 'totalCycles', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetSeconds', 'presetCycles', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`emom_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#emom_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#emom_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#emom_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#emom_presetModal [data-modal-close], #emom_notesModal [data-modal-close], #emom_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#emom_presetModal [data-modal-cancel]');
         // Shared workout view elements
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutProgress = document.getElementById('workoutProgress');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyCycleSeconds(parseInt(btn.dataset.quick, 10))));
        this.els.secInput.addEventListener('input', () => this.handleSecInputTyping());
        this.els.secInput.addEventListener('blur', () => this.handleSecInputBlur());
        this.els.targetInput.addEventListener('input', () => this.handleTargetInputChange());
        this.els.targetInput.addEventListener('blur', () => {
            const val = parseInt(this.els.targetInput.value, 10);
            if (val <= 0) {
                this.els.targetInput.value = '';
                this.handleTargetInputChange();
            } else if (!isNaN(val)) {
                this.els.targetInput.value = val;
                this.handleTargetInputChange();
            }
        });
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && EmomApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && EmomApp.running) this.handleWorkoutPause() });

        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;

            const { action, id, index } = target.dataset;

            switch(action) {
                case 'apply-preset':
                    this.applyPreset(parseInt(index, 10));
                    break;
                case 'delete-preset':
                    e.stopPropagation();
                    if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10));
                    break;
                case 'edit-preset':
                    this.openPresetModal(parseInt(index, 10));
                    break;
                case 'clear-history':
                    this.clearHistory();
                    break;
                case 'export-history':
                    this.exportHistory();
                    break;
                case 'edit-history':
                    this.openNotesModal(parseInt(id, 10));
                    break;
                case 'share-history':
                    this.shareWorkout(parseInt(id, 10));
                    break;
                case 'delete-history':
                    if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10));
                    break;
            }
        });
      },
      
      updateLanguage() {
        this.updateUI();
        this.renderPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `emom_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderPresets();
      },

      applyCycleSeconds(n) {
        if (isNaN(n)) return;
        this.cycleSeconds = Math.max(10, Math.min(999, n));
        this.els.secInput.value = this.cycleSeconds;
        this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === this.cycleSeconds));
        if (!this.running || this.paused) {
          this.remaining = this.cycleSeconds;
          this.updateUI();
        }
      },

      handleSecInputTyping() {
        let value = parseInt(this.els.secInput.value, 10);

        if (!isNaN(value)) {
            this.cycleSeconds = value;
            this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === this.cycleSeconds));
            if (!this.running || this.paused) {
                this.remaining = this.cycleSeconds;
                this.updateUI();
            }
        }
      },

      handleSecInputBlur() {
        let value = parseInt(this.els.secInput.value, 10);
        if (isNaN(value) || value < 10) {
            value = this.cycleSeconds > 10 ? this.cycleSeconds : 60; 
        }
        this.applyCycleSeconds(value);
      },

      handleTargetInputChange() {
        let value = this.els.targetInput.value.replace(/[^0-9]/g, '');
        this.targetCycles = value === '' ? null : parseInt(value, 10);
        this.updateUI();
      },
      
      updateUI() {
        this.els.timer.textContent = this.remaining;
        this.els.cycles.textContent = t('completed_cycles') + ' ' + this.cycles;
        if (this.targetCycles > 0) {
          this.els.progress.textContent = `${t('progress')} ${this.cycles}/${this.targetCycles}`;
          this.els.progress.style.color = this.cycles >= this.targetCycles ? 'var(--success)' : 'var(--muted-text)';
        } else {
          this.els.progress.textContent = '';
        }
        if(this.workoutViewActive) this.updateWorkoutView();
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },

      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        if (this.running && !this.paused) return;
        this.handleSecInputBlur(); // Ensure the value is validated before starting
        this.remaining = this.cycleSeconds;
        this.cycles = 0;
        this.updateUI();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.startCycleTick();
          this.openWorkoutView();
        });
        this.els.startBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
        this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
      },
      
      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = null;
        this.setStatus('paused', 'paused');
        releaseWakeLock();
        this.els.resumeBtn.disabled = false;
        this.els.startBtn.disabled = true;
        this.els.pauseBtn.disabled = true;
        this.updateUI();
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.setStatus('training', 'running');
        this.els.resumeBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false; this.inPrep = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.animationFrameId = null; this.prepInterval = null;
        releaseWakeLock();
        this.cycles = 0; 
        this.remaining = this.cycleSeconds; 
        this.els.prep.style.display = 'none'; 
        this.els.timer.style.display = 'block';
        this.setStatus('ready', 'idle');
        this.els.resumeBtn.disabled = true; 
        this.els.startBtn.disabled = false; 
        this.els.pauseBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
        this.updateUI();
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.inPrep = true;
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        this.setStatus('preparing', 'ready');
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval); this.prepInterval = null;
            ring();
            setTimeout(() => {
              this.inPrep = false;
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },
      
      startCycleTick() {
        this.setStatus('training', 'running');
        this.running = true; this.paused = false;
        this.startTime = performance.now();
        this.pausedDuration = 0;
        this.lastAnnouncedSecond = null;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      tick() {
        if (!this.running || this.paused || this.inPrep) return;

        const elapsedMs = performance.now() - this.startTime - this.pausedDuration;
        const cycleDurationMs = this.cycleSeconds * 1000;

        const newCycles = Math.floor(elapsedMs / cycleDurationMs);
        if (newCycles > this.cycles) {
          this.cycles = newCycles;
          ring();
          if (this.targetCycles && this.cycles >= this.targetCycles) {
            this.completeWorkout();
            return;
          }
        }
        
        const elapsedInCycle = elapsedMs % cycleDurationMs;
        const newRemaining = this.cycleSeconds - Math.floor(elapsedInCycle / 1000);

        if(this.remaining !== newRemaining) {
            this.remaining = newRemaining;
            this.updateUI();
        }

        if (this.remaining <= 5 && this.remaining > 0 && this.lastAnnouncedSecond !== this.remaining) {
          beepShort();
          this.lastAnnouncedSecond = this.remaining;
        } else if (this.remaining > 5) {
          this.lastAnnouncedSecond = null;
        }

        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      completeWorkout() {
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        releaseWakeLock();
        this.setStatus('workout_complete_status', 'completed');
        victoryBells();
        this.saveWorkout({ cycles: this.cycles, secondsPerCycle: this.cycleSeconds, totalTime: this.cycles * this.cycleSeconds });
        this.closeWorkoutView();
        setTimeout(() => this.els.notesModal.classList.add('active'), 1000);
        setTimeout(() => this.resetAll(), 1200);
      },

      // Workout View
      openWorkoutView() {
        this.workoutViewActive = true;
        // Configure for EMOM
        document.getElementById('workoutStatus').style.display = 'none';
        document.getElementById('workoutLapBtn').style.display = 'none';
        document.getElementById('workoutLapsList').parentElement.style.display = 'none';
        this.els.workoutProgress.style.display = 'block';
        this.els.workoutTimer.classList.remove('fortime');
        this.els.workoutTimer.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden';
        this.updateWorkoutView();
      },
      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = '';
      },
      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        this.els.workoutTimer.textContent = this.remaining;
        
        if (this.targetCycles > 0) {
          this.els.workoutProgress.textContent = `${t('cycles')} ${this.cycles}/${this.targetCycles}`;
        } else {
          this.els.workoutProgress.textContent = `${t('completed_cycles')} ${this.cycles}`;
        }

        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        this.els.workoutPauseBtn.disabled = !this.running;
      },
      handleWorkoutPause() {
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },
      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },
      
      // Presets
      getPresets() { return JSON.parse(localStorage.getItem('emom_presets') || '[]'); },
      savePresets(presets) { localStorage.setItem('emom_presets', JSON.stringify(presets)); },
      renderPresets() {
        const presets = this.getPresets();
        // Clear only the user presets, not the "add new" button if it were here
        this.els.presetsContainer.innerHTML = '';
        presets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">Ã—</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          const presets = this.getPresets();
          if (!presets[index]) return;
          const preset = presets[index];
          this.applyCycleSeconds(preset.seconds);
          this.els.targetInput.value = preset.cycles || '';
          this.handleTargetInputChange();
      },
      deletePreset(index) {
          let presets = this.getPresets();
          presets.splice(index, 1);
          this.savePresets(presets);
          this.renderPresets();
      },
      loadPresetsList() {
        const presets = this.getPresets();
        if (presets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = presets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${p.seconds}s ${t('seconds_per_cycle_short')} ${p.cycles ? `â€¢ ${p.cycles} ${t('target_cycles_short')}`: `â€¢ ${t('leave_empty_unlimited')}`}</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        const presets = this.getPresets();
        if (index > -1 && presets[index]) {
          const p = presets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title');
          this.els.presetName.value = p.name;
          this.els.presetSeconds.value = p.seconds;
          this.els.presetCycles.value = p.cycles || '';
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title');
          this.els.presetName.value = '';
          this.els.presetSeconds.value = this.cycleSeconds;
          this.els.presetCycles.value = this.targetCycles || '';
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const seconds = parseInt(this.els.presetSeconds.value);
        const cycles = this.els.presetCycles.value ? parseInt(this.els.presetCycles.value) : null;
        if (!name || !seconds || seconds < 10) { alert(t('alert_fill_fields')); return; }
        
        const presets = this.getPresets();
        const newPreset = { name, seconds, cycles };

        if (this.editingPresetIndex > -1) {
          presets[this.editingPresetIndex] = newPreset;
        } else {
          presets.push(newPreset);
        }
        this.savePresets(presets);
        this.renderPresets();
        this.closeAllModals();
      },
      
      // History
      getHistory() { return JSON.parse(localStorage.getItem('emom_history') || '[]'); },
      saveHistory(history) { localStorage.setItem('emom_history', JSON.stringify(history)); },
      loadHistory() {
        const history = this.getHistory();
        this.els.totalWorkouts.textContent = history.length;
        this.els.totalCycles.textContent = history.reduce((sum, w) => sum + (w.cycles || 0), 0);
        if (history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = history.map(w => {
          const date = new Date(w.date);
          const duration = Math.floor((w.totalTime) / 60);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} â€¢ ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${w.cycles} cycles Ã— ${w.secondsPerCycle}s</div>
            <div class="history-details">${duration}min workout</div>
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          this.saveHistory([]);
          this.loadHistory();
        }
      },
      exportHistory() {
        const history = this.getHistory();
        if (history.length === 0) return;
        const head = ['date', 'secondsPerCycle', 'completedCycles', 'totalTimeSeconds', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          w.secondsPerCycle,
          w.cycles,
          w.totalTime,
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'emom_history.csv');
      },
      saveWorkout(data, notes = '') {
        const workout = { id: Date.now(), date: new Date().toISOString(), ...data, notes };
        let history = this.getHistory();
        history.unshift(workout);
        if (history.length > 50) history.pop();
        this.saveHistory(history);
        this.currentWorkout = workout;
      },
      updateWorkoutNotes(id, notes) {
        let history = this.getHistory();
        const workout = history.find(w => w.id === id);
        if (workout) {
          workout.notes = notes;
          this.saveHistory(history);
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          let history = this.getHistory();
          history = history.filter(w => w.id !== id);
          this.saveHistory(history);
          this.loadHistory();
      },
      
      // Modals
      closeAllModals() {
        document.querySelectorAll('#emom_presetModal, #emom_notesModal, #emom_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) this.showCompletionModal();
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));
        if (workoutId) {
          this.updateWorkoutNotes(workoutId, notes);
        } else if (this.currentWorkout) {
          this.updateWorkoutNotes(this.currentWorkout.id, notes);
          this.currentWorkout.notes = notes;
        }
        this.closeAllModals();
        if (this.currentWorkout && !workoutId) {
          this.showCompletionModal();
        }
      },
      openNotesModal(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          this.els.workoutNotes.value = workout.notes || '';
          this.els.notesModal.setAttribute('data-workout-id', id);
          this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        const duration = Math.floor(this.currentWorkout.totalTime / 60);
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${this.currentWorkout.cycles}</strong> cycles completed</div>
          <div class="completion-stat"><strong>${this.currentWorkout.secondsPerCycle}s</strong> per cycle</div>
          <div class="completion-stat"><strong>${duration} minutes</strong> total workout</div>`;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        this.els.workoutNotes.value = this.currentWorkout?.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', this.currentWorkout.id);
        this.els.notesModal.classList.add('active');
      },
      shareResult() {
        if (!this.currentWorkout) return;
        this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          const date = new Date(workout.date).toLocaleDateString();
          const duration = Math.floor(workout.totalTime / 60);
          const notesText = workout.notes ? `\n\nNotes: ${workout.notes}` : '';
          const text = t('share_text_emom', {
            cycles: workout.cycles,
            seconds: workout.secondsPerCycle,
            duration: duration,
            date: date,
            notes: notesText
          });
          if (navigator.share) {
            navigator.share({ title: 'EMOM Workout Complete!', text });
          } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
          }
      },
      
      loadSettingsFromLocalStorage() {
        this.applyCycleSeconds(localStorage.getItem('emom_cycleSeconds') || 60);
        this.els.targetInput.value = localStorage.getItem('emom_targetCycles') || '';
        this.handleTargetInputChange();
      },
    };

    // === TABATA APP LOGIC ===
    const TabataApp = {
      workTime: 20, restTime: 10, totalCycles: 8,
      mode: 'idle', // 'prep', 'work', 'rest', 'paused', 'completed'
      currentCycle: 0, timeRemaining: 20,
      running: false, paused: false, prepInterval: null,
      animationFrameId: null, startTime: 0, pauseTime: 0, pausedDuration: 0,
      lastAnnouncedSecond: null, editingPresetIndex: -1,
      currentWorkout: null,
      history: [], customPresets: [], initialized: false,
      workoutViewActive: false,
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.history = JSON.parse(localStorage.getItem('tabata_history') || '[]');
        this.customPresets = JSON.parse(localStorage.getItem('tabata_presets') || '[]');
        this.setupEventListeners();
        this.updateUI();
        this.renderCustomPresets();
        this.loadHistory();
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'timer', 'prep', 'status', 'progress', 'workInput', 'restInput', 'cyclesInput', 'startBtn', 'pauseBtn', 'resumeBtn', 'resetBtn', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsContainer', 'addPresetBtn', 'quick', 'presetsList', 'historyList', 'totalWorkouts', 'totalCycles', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetWork', 'presetRest', 'presetCycles', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`tabata_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#tabata_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#tabata_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#tabata_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#tabata_presetModal [data-modal-close], #tabata_notesModal [data-modal-close], #tabata_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#tabata_presetModal [data-modal-cancel]');
         // Shared workout view elements
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutProgress = document.getElementById('workoutProgress');
        this.els.workoutStatus = document.getElementById('workoutStatus');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyQuickPreset(btn)));
        ['workInput', 'restInput', 'cyclesInput'].forEach(key => {
            this.els[key].addEventListener('input', () => this.updateValues());
            this.els[key].addEventListener('blur', () => this.validateTabataInputs());
        });
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && TabataApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && TabataApp.running) this.handleWorkoutPause() });
        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;

            const { action, id, index } = target.dataset;

            switch(action) {
                case 'apply-preset':
                    this.applyPreset(parseInt(index, 10));
                    break;
                case 'delete-preset':
                    e.stopPropagation();
                    if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10));
                    break;
                case 'edit-preset':
                    this.openPresetModal(parseInt(index, 10));
                    break;
                case 'clear-history':
                    this.clearHistory();
                    break;
                case 'export-history':
                    this.exportHistory();
                    break;
                case 'edit-history':
                    this.openNotesModal(parseInt(id, 10));
                    break;
                case 'share-history':
                    this.shareWorkout(parseInt(id, 10));
                    break;
                case 'delete-history':
                    if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10));
                    break;
            }
        });
      },

      validateTabataInputs() {
        let workVal = parseInt(this.els.workInput.value, 10);
        this.els.workInput.value = (!isNaN(workVal) && workVal > 0) ? workVal : 20;

        let restVal = parseInt(this.els.restInput.value, 10);
        this.els.restInput.value = (!isNaN(restVal) && restVal >= 0) ? restVal : 10;

        let cyclesVal = parseInt(this.els.cyclesInput.value, 10);
        this.els.cyclesInput.value = (!isNaN(cyclesVal) && cyclesVal > 0) ? cyclesVal : 8;
        
        this.updateValues();
      },
      
      updateLanguage() {
        this.updateUI();
        this.renderCustomPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `tabata_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderCustomPresets();
      },
      
      applyQuickPreset(btn) {
        const presetStr = btn.dataset.preset;
        const [work, rest, cycles] = presetStr.split('-').map(Number);
        this.els.workInput.value = work;
        this.els.restInput.value = rest;
        this.els.cyclesInput.value = cycles;
        this.updateValues();
        document.querySelectorAll('#tabata_app .preset-btn, #tabata_app .quick-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      },
      
      updateValues() {
        this.workTime = parseInt(this.els.workInput.value) || 20;
        this.restTime = parseInt(this.els.restInput.value) || 10;
        this.totalCycles = parseInt(this.els.cyclesInput.value) || 8;
        if (!this.running) {
          this.timeRemaining = this.workTime;
          this.updateUI();
        }
      },
      
      updateUI() {
        this.els.timer.textContent = this.timeRemaining;
        this.els.progress.textContent = `${t('progress').replace(':', '')} ${this.currentCycle}/${this.totalCycles}`;
        
        const statusMap = {
          idle: { key: 'ready', class: 'idle' },
          prep: { key: 'preparing', class: 'ready' },
          work: { key: 'status_work', class: 'running' },
          rest: { key: 'status_rest', class: 'paused' },
          paused: { key: 'paused', class: 'paused' },
          completed: { key: 'workout_complete_status', class: 'completed' },
        };
        const newStatus = statusMap[this.mode] || statusMap.idle;
        this.setStatus(newStatus.key, newStatus.class);

        if (this.workoutViewActive) this.updateWorkoutView();
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },
      
      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        this.updateValues();
        this.currentCycle = 0;
        this.timeRemaining = this.workTime;
        this.running = true;
        this.paused = false;
        this.els.startBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
        this.els.resumeBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
        this.updateUI();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.startTiming();
          this.openWorkoutView();
        });
      },
      
      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.animationFrameId = null; this.prepInterval = null;
        this.mode = 'paused';
        this.updateUI();
        releaseWakeLock();
        this.els.resumeBtn.disabled = false;
        this.els.startBtn.disabled = true;
        this.els.pauseBtn.disabled = true;
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.updateUI(); // mode will be updated in tick
        this.els.resumeBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.animationFrameId = null; this.prepInterval = null;
        releaseWakeLock();
        this.mode = 'idle';
        this.currentCycle = 0;
        this.updateValues();
        this.els.prep.style.display = 'none';
        this.els.timer.style.display = 'block';
        this.updateUI();
        this.els.startBtn.disabled = false;
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.mode = 'prep';
        this.updateUI();
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval);
            this.prepInterval = null;
            ring();
            setTimeout(() => {
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },

      startTiming() {
        this.startTime = performance.now();
        this.pausedDuration = 0;
        this.lastAnnouncedSecond = null;
        if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      tick() {
        if (!this.running || this.paused) return;
        
        const elapsedMs = performance.now() - this.startTime - this.pausedDuration;
        const totalCycleDurationMs = (this.workTime + this.restTime) * 1000;
        
        const newCycle = Math.floor(elapsedMs / totalCycleDurationMs);
        if(this.currentCycle !== newCycle) {
            this.currentCycle = newCycle;
        }

        if(this.currentCycle >= this.totalCycles) {
            this.completeWorkout();
            return;
        }

        const elapsedInCurrentCycleMs = elapsedMs % totalCycleDurationMs;
        const workTimeMs = this.workTime * 1000;
        let newMode, newRemaining;
        
        if (elapsedInCurrentCycleMs < workTimeMs) {
            newMode = 'work';
            newRemaining = this.workTime - Math.floor(elapsedInCurrentCycleMs / 1000);
        } else {
            newMode = 'rest';
            const elapsedInRest = elapsedInCurrentCycleMs - workTimeMs;
            newRemaining = this.restTime - Math.floor(elapsedInRest / 1000);
        }
        
        if (this.mode !== newMode) {
            this.mode = newMode;
            ring();
        }
        if(this.timeRemaining !== newRemaining) {
            this.timeRemaining = newRemaining;
            this.updateUI();
        }

        if (this.timeRemaining <= 5 && this.timeRemaining > 0 && this.lastAnnouncedSecond !== this.timeRemaining) {
          beepShort();
          this.lastAnnouncedSecond = this.timeRemaining;
        } else if (this.timeRemaining > 5) {
          this.lastAnnouncedSecond = null;
        }

        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      completeWorkout() {
        this.closeWorkoutView();
        this.running = false; this.paused = false;
        if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        this.mode = 'completed';
        this.updateUI();
        victoryBells();
        releaseWakeLock();
        
        this.currentWorkout = {
          id: Date.now(), date: new Date().toISOString(), cycles: this.totalCycles, work: this.workTime,
          rest: this.restTime, totalTime: this.totalCycles * (this.workTime + this.restTime)
        };
        
        this.els.startBtn.disabled = false;
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        
        setTimeout(() => {
          this.els.workoutNotes.value = '';
          this.els.notesModal.setAttribute('data-workout-id', '');
          this.els.notesModal.classList.add('active');
        }, 1000);
      },
      
      // Workout View
      openWorkoutView() {
        this.workoutViewActive = true;
        // Configure for Tabata
        this.els.workoutStatus.style.display = 'block';
        document.getElementById('workoutLapBtn').style.display = 'none';
        document.getElementById('workoutLapsList').parentElement.style.display = 'none';
        this.els.workoutProgress.style.display = 'block';
        this.els.workoutTimer.classList.remove('fortime');
        this.els.workoutTimer.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden';
        this.updateWorkoutView();
      },
      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = '';
      },
      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        
        this.els.workoutTimer.textContent = this.timeRemaining;
        this.els.workoutProgress.textContent = `${t('progress').replace(':', '')} ${this.currentCycle}/${this.totalCycles}`;
        
        const statusMap = {
            work: { key: 'status_work', color: 'var(--accent)' },
            rest: { key: 'status_rest', color: 'var(--warn)' },
        };
        
        const currentStatus = statusMap[this.mode];
        if (currentStatus) {
            this.els.workoutStatus.textContent = t(currentStatus.key);
            this.els.workoutStatus.style.color = currentStatus.color;
            this.els.workoutStatus.style.display = 'block';
        } else {
            this.els.workoutStatus.style.display = 'none';
        }

        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        this.els.workoutPauseBtn.disabled = !this.running;
      },
      handleWorkoutPause() {
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },
      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },
      
      // Presets
      renderCustomPresets() {
        // Clear only the user presets, not the "add new" button
        this.els.presetsContainer.innerHTML = '';
        this.customPresets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">Ã—</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          if (!this.customPresets[index]) return;
          const preset = this.customPresets[index];
          this.els.workInput.value = preset.work;
          this.els.restInput.value = preset.rest;
          this.els.cyclesInput.value = preset.cycles;
          this.updateValues();
          document.querySelectorAll('#tabata_app .preset-btn, #tabata_app .quick-btn').forEach(b => b.classList.remove('active'));
          // Find the button and activate it
          const btnToActivate = this.els.presetsContainer.querySelector(`[data-index="${index}"]`);
          if (btnToActivate) btnToActivate.classList.add('active');
      },
      loadPresetsList() {
        if (this.customPresets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets_tabata')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = this.customPresets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${p.work}s ${t('work_seconds_short')} â€¢ ${p.rest}s ${t('rest_seconds_short')} â€¢ ${p.cycles} ${t('cycles')}</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        if (index > -1 && this.customPresets[index]) {
          const p = this.customPresets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title_tabata');
          this.els.presetName.value = p.name;
          this.els.presetWork.value = p.work;
          this.els.presetRest.value = p.rest;
          this.els.presetCycles.value = p.cycles;
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title_tabata');
          this.els.presetName.value = '';
          this.els.presetWork.value = this.workTime;
          this.els.presetRest.value = this.restTime;
          this.els.presetCycles.value = this.totalCycles;
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const work = parseInt(this.els.presetWork.value);
        const rest = parseInt(this.els.presetRest.value);
        const cycles = parseInt(this.els.presetCycles.value);
        if (!name || !work || !rest || !cycles) { alert(t('alert_fill_fields')); return; }
        const preset = { name, work, rest, cycles };
        if (this.editingPresetIndex >= 0) {
          this.customPresets[this.editingPresetIndex] = preset;
        } else {
          this.customPresets.push(preset);
        }
        localStorage.setItem('tabata_presets', JSON.stringify(this.customPresets));
        this.renderCustomPresets();
        this.closeAllModals();
      },
      deletePreset(index) {
          this.customPresets.splice(index, 1);
          localStorage.setItem('tabata_presets', JSON.stringify(this.customPresets));
          this.renderCustomPresets();
      },

      // History
      loadHistory() {
        this.els.totalWorkouts.textContent = this.history.length;
        this.els.totalCycles.textContent = this.history.reduce((sum, w) => sum + (w.cycles || 0), 0);
        if (this.history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history_tabata')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = this.history.map(w => {
          const date = new Date(w.date);
          const duration = Math.floor(w.totalTime / 60);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} â€¢ ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${w.cycles} ${t('cycles')} â€¢ ${w.work}s/${w.rest}s</div>
            <div class="history-details">${duration}min workout</div>
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      exportHistory() {
        const history = this.history;
        if (history.length === 0) return;
        const head = ['date', 'workSeconds', 'restSeconds', 'completedCycles', 'totalTimeSeconds', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          w.work,
          w.rest,
          w.cycles,
          w.totalTime,
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'tabata_history.csv');
      },
      saveWorkout(notes = '') {
        if (!this.currentWorkout) return;
        this.currentWorkout.notes = notes;
        this.history.unshift(this.currentWorkout);
        if (this.history.length > 50) this.history.pop();
        localStorage.setItem('tabata_history', JSON.stringify(this.history));
        this.loadHistory();
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          localStorage.removeItem('tabata_history');
          this.history = [];
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          this.history = this.history.filter(w => w.id !== id);
          localStorage.setItem('tabata_history', JSON.stringify(this.history));
          this.loadHistory();
      },

      // Modals
      closeAllModals() {
        document.querySelectorAll('#tabata_presetModal, #tabata_notesModal, #tabata_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) {
          this.saveWorkout('');
          this.showCompletionModal();
        }
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));

        if (workoutId) {
          const workout = this.history.find(w => w.id === workoutId);
          if (workout) {
            workout.notes = notes;
            localStorage.setItem('tabata_history', JSON.stringify(this.history));
          }
          this.loadHistory();
        } else if (this.currentWorkout) {
          this.saveWorkout(notes);
          this.showCompletionModal();
        }
        this.closeAllModals();
      },
      openNotesModal(id) {
        const workout = this.history.find(w => w.id === id);
        if (!workout) return;
        this.els.workoutNotes.value = workout.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', id);
        this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        const duration = Math.floor(this.currentWorkout.totalTime / 60);
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${this.currentWorkout.cycles}</strong> ${t('cycles')} ${t('completed_cycles')}</div>
          <div class="completion-stat"><strong>${this.currentWorkout.work}s</strong> ${t('work_seconds_short')} / <strong>${this.currentWorkout.rest}s</strong> ${t('rest_seconds_short')}</div>
          <div class="completion-stat"><strong>${duration}</strong> ${t('minutes_total')}</div>`;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        if (this.currentWorkout) {
          this.openNotesModal(this.currentWorkout.id);
        }
      },
      shareResult() {
        if(this.currentWorkout) this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
        const workout = this.history.find(w => w.id === id);
        if (!workout) return;
        const date = new Date(workout.date).toLocaleDateString();
        const duration = Math.floor(workout.totalTime / 60);
        const notesText = workout.notes ? `\n\n${t('workout_notes')}: ${workout.notes}` : '';
        const text = t('share_text_tabata', {
          cycles: workout.cycles,
          work: workout.work,
          rest: workout.rest,
          duration: duration,
          date: date,
          notes: notesText
        });

        if (navigator.share) {
          navigator.share({ title: t('share_title_tabata'), text });
        } else if (navigator.clipboard) {
          navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
        }
      }
    };

    // === FOR TIME APP LOGIC ===
    const ForTimeApp = {
      // State
      timeCap: null, prepInterval: null, running: false, paused: false, inPrep: false,
      startTime: 0, pauseTime: 0, pausedDuration: 0, elapsedTime: 0,
      laps: [], animationFrameId: null,
      currentWorkout: null, editingPresetIndex: -1, initialized: false,
      workoutViewActive: false,
      lastAnnouncedCapSecond: null,
      midpointAnnounced: false,
      
      // DOM Elements
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.renderPresets();
        this.loadHistory();
        this.updateUI();
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'timeCapInput', 'status', 'prep', 'timer', 'startBtn', 'stopBtn', 'pauseBtn', 'resumeBtn', 'lapBtn', 'resetBtn', 'lapsList', 'presetsContainer', 'addPresetBtn', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsList', 'historyList', 'totalWorkouts', 'totalLaps', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetTimeCap', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`fortime_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#fortime_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#fortime_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#fortime_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#fortime_presetModal [data-modal-close], #fortime_notesModal [data-modal-close], #fortime_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#fortime_presetModal [data-modal-cancel]');
        // Elementos de la vista de entrenamiento
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutLapBtn = document.getElementById('workoutLapBtn');
        this.els.workoutLapsList = document.getElementById('workoutLapsList');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyTimeCap(parseInt(btn.dataset.quick, 10))));
        this.els.timeCapInput.addEventListener('input', () => this.handleTimeCapChange());
        this.els.timeCapInput.addEventListener('blur', () => this.validateForTimeInputs());
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.stopBtn.addEventListener('click', () => this.stop());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.lapBtn.addEventListener('click', () => this.lap());
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;
            const { action, id, index } = target.dataset;
            switch(action) {
                case 'apply-preset': this.applyPreset(parseInt(index, 10)); break;
                case 'delete-preset': e.stopPropagation(); if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10)); break;
                case 'edit-preset': this.openPresetModal(parseInt(index, 10)); break;
                case 'clear-history': this.clearHistory(); break;
                case 'export-history': this.exportHistory(); break;
                case 'edit-history': this.openNotesModal(parseInt(id, 10)); break;
                case 'share-history': this.shareWorkout(parseInt(id, 10)); break;
                case 'delete-history': if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10)); break;
            }
        });
         // Event listeners para la vista de entrenamiento
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && ForTimeApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && ForTimeApp.running) this.handleWorkoutPause() });
        this.els.workoutLapBtn.addEventListener('click', () => { if(this.workoutViewActive && ForTimeApp.running) this.lap()});
      },
      
      validateForTimeInputs() {
        let val = parseInt(this.els.timeCapInput.value, 10);
        if (isNaN(val) || val <= 0) {
            this.els.timeCapInput.value = '';
        } else {
            this.els.timeCapInput.value = val;
        }
        this.handleTimeCapChange();
      },

      openWorkoutView() {
        this.workoutViewActive = true;
        // Configure for ForTime
        document.getElementById('workoutStatus').style.display = 'none';
        document.getElementById('workoutProgress').style.display = 'none';
        this.els.workoutLapBtn.style.display = 'inline-block';
        this.els.workoutLapsList.parentElement.style.display = 'block';
        this.els.workoutTimer.classList.add('fortime');
        this.els.workoutTimer.style.fontFamily = 'monospace';
        
        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevenir scroll del body
        this.els.workoutLapBtn.textContent = t('lap');
        this.updateWorkoutView();
      },

      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = ''; // Restaurar scroll
      },

      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        
        this.els.workoutTimer.textContent = this.formatTime(this.elapsedTime);
        
        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        
        this.els.workoutLapsList.innerHTML = this.laps.map((lapTime, i) => `
          <li class="lap-item">
            <span>${t('lap')} ${i + 1}</span>
            <span>${this.formatTime(lapTime)}</span>
          </li>
        `).reverse().join('');
        
        this.els.workoutPauseBtn.disabled = !this.running;
        this.els.workoutLapBtn.disabled = !this.running || this.paused;
      },

      handleWorkoutPause() {
        if (!this.running) return;
        
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },

      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },

      updateLanguage() {
        this.updateUI();
        this.renderPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `fortime_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderPresets();
      },
      
      applyTimeCap(minutes) {
        if (isNaN(minutes)) return;
        this.els.timeCapInput.value = minutes;
        this.handleTimeCapChange();
      },

      handleTimeCapChange() {
        const val = this.els.timeCapInput.value.trim();
        const minutes = val ? parseInt(val, 10) : null;
        this.timeCap = minutes ? minutes * 60 * 1000 : null; // convert minutes to ms
        if(this.els.quickBtns) { // check if it exists
             this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === minutes));
        }
      },

      formatTime(ms) {
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        const centiseconds = Math.floor((ms % 1000) / 10);
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
      },

      updateUI() {
        this.els.timer.textContent = this.formatTime(this.elapsedTime);
        this.renderLaps();
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },

      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        this.resetAll();
        this.handleTimeCapChange();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.running = true;
          this.startTime = performance.now();
          this.pausedDuration = 0;
          this.animationFrameId = requestAnimationFrame(() => this.tick());
          this.setStatus('training', 'running');
          this.els.startBtn.style.display = 'none';
          this.els.stopBtn.style.display = 'inline-block';
          this.els.pauseBtn.disabled = false;
          this.els.lapBtn.disabled = false;
          this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
          this.openWorkoutView();
        });
      },

      stop(isTimeCap = false) {
        if (!this.running) return;
        this.closeWorkoutView();
        this.running = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if(!isTimeCap) this.elapsedTime = performance.now() - this.startTime - this.pausedDuration;
        this.updateUI();
        this.completeWorkout();
      },

      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) { clearInterval(this.prepInterval); this.prepInterval = null; }
        this.setStatus('paused', 'paused');
        releaseWakeLock();
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = false;
        this.els.lapBtn.disabled = true;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.setStatus('training', 'running');
        this.els.pauseBtn.disabled = false;
        this.els.resumeBtn.disabled = true;
        this.els.lapBtn.disabled = false;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },

      lap() {
        if (!this.running || this.paused) return;
        this.laps.push(this.elapsedTime);
        this.renderLaps();
        beepShort();
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false; this.inPrep = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        releaseWakeLock();
        this.elapsedTime = 0; this.laps = []; this.pausedDuration = 0;
        this.lastAnnouncedCapSecond = null;
        this.midpointAnnounced = false;
        this.els.prep.style.display = 'none'; 
        this.els.timer.style.display = 'block';
        this.setStatus('ready', 'idle');
        this.els.startBtn.style.display = 'inline-block';
        this.els.stopBtn.style.display = 'none';
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.lapBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
        this.updateUI();
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.inPrep = true;
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        this.setStatus('preparing', 'ready');
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval); this.prepInterval = null;
            ring();
            setTimeout(() => {
              this.inPrep = false;
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },
      
      tick() {
        if (!this.running || this.paused) return;
        this.elapsedTime = performance.now() - this.startTime - this.pausedDuration;

        if (this.timeCap) {
          if (this.elapsedTime >= this.timeCap) {
            this.elapsedTime = this.timeCap;
            this.stop(true);
            return;
          }

          // Midpoint sound alert
          if (!this.midpointAnnounced && this.elapsedTime >= (this.timeCap / 2)) {
            ring();
            this.midpointAnnounced = true;
          }

          // Final countdown before time cap
          const timeRemainingMs = this.timeCap - this.elapsedTime;
          const secondsRemaining = Math.ceil(timeRemainingMs / 1000);

          if (secondsRemaining <= 5 && secondsRemaining > 0) {
            if (this.lastAnnouncedCapSecond !== secondsRemaining) {
              beepShort();
              this.lastAnnouncedCapSecond = secondsRemaining;
            }
          }
        }

        this.updateUI();
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      renderLaps() {
        this.els.lapsList.innerHTML = this.laps.map((lapTime, i) => `
          <li class="lap-item">
            <span>${t('lap')} ${i + 1}</span>
            <span>${this.formatTime(lapTime)}</span>
          </li>
        `).reverse().join('');
      },

      completeWorkout() {
        releaseWakeLock();
        this.setStatus('workout_complete_status', 'completed');
        victoryBells();
        this.saveWorkout({ finalTime: this.elapsedTime, timeCap: this.timeCap, laps: this.laps });
        setTimeout(() => this.els.notesModal.classList.add('active'), 1000);
      },
      
      // Presets
      getPresets() { return JSON.parse(localStorage.getItem('fortime_presets') || '[]'); },
      savePresets(presets) { localStorage.setItem('fortime_presets', JSON.stringify(presets)); },
      renderPresets() {
        const presets = this.getPresets();
        this.els.presetsContainer.innerHTML = '';
        presets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">Ã—</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          const presets = this.getPresets();
          if (!presets[index]) return;
          const preset = presets[index];
          this.els.timeCapInput.value = preset.timeCap || '';
          this.handleTimeCapChange();
      },
      deletePreset(index) {
          let presets = this.getPresets();
          presets.splice(index, 1);
          this.savePresets(presets);
          this.renderPresets();
      },
      loadPresetsList() {
        const presets = this.getPresets();
        if (presets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets_fortime')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = presets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${p.timeCap ? `${t('time_cap')} ${p.timeCap} min` : t('leave_empty_unlimited')}</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        const presets = this.getPresets();
        if (index > -1 && presets[index]) {
          const p = presets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title_fortime');
          this.els.presetName.value = p.name;
          this.els.presetTimeCap.value = p.timeCap || '';
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title_fortime');
          this.els.presetName.value = '';
          this.els.presetTimeCap.value = this.timeCap ? this.timeCap / 60000 : '';
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const timeCap = this.els.presetTimeCap.value ? parseInt(this.els.presetTimeCap.value) : null;
        if (!name) { alert(t('alert_fill_fields')); return; }
        
        const presets = this.getPresets();
        const newPreset = { name, timeCap };

        if (this.editingPresetIndex > -1) {
          presets[this.editingPresetIndex] = newPreset;
        } else {
          presets.push(newPreset);
        }
        this.savePresets(presets);
        this.renderPresets();
        this.closeAllModals();
      },
      
      // History
      getHistory() { return JSON.parse(localStorage.getItem('fortime_history') || '[]'); },
      saveHistory(history) { localStorage.setItem('fortime_history', JSON.stringify(history)); },
      loadHistory() {
        const history = this.getHistory();
        this.els.totalWorkouts.textContent = history.length;
        this.els.totalLaps.textContent = history.reduce((sum, w) => sum + (w.laps?.length || 0), 0);
        if (history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history_fortime')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = history.map(w => {
          const date = new Date(w.date);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} â€¢ ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${t('final_time')}: ${this.formatTime(w.finalTime)}</div>
            <div class="history-details">${w.laps.length} Laps ${w.timeCap ? `â€¢ Time Cap: ${w.timeCap / 60000}min` : ''}</div>
            ${w.laps && w.laps.length > 0 ? `
              <div class="history-laps">
                <ul>
                  ${w.laps.map((lapTime, i) => `<li>${t('lap')} ${i + 1}: ${this.formatTime(lapTime)}</li>`).join('')}
                </ul>
              </div>
            ` : ''}
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      exportHistory() {
        const history = this.getHistory();
        if (history.length === 0) return;
        const head = ['date', 'finalTime', 'timeCapMinutes', 'lapsCount', 'laps', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          this.formatTime(w.finalTime),
          w.timeCap ? w.timeCap / 60000 : '',
          w.laps.length,
          w.laps.map(l => this.formatTime(l)).join('; '),
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'fortime_history.csv');
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          this.saveHistory([]);
          this.loadHistory();
        }
      },
      saveWorkout(data, notes = '') {
        const workout = { id: Date.now(), date: new Date().toISOString(), ...data, notes };
        let history = this.getHistory();
        history.unshift(workout);
        if (history.length > 50) history.pop();
        this.saveHistory(history);
        this.currentWorkout = workout;
        this.loadHistory();
      },
      updateWorkoutNotes(id, notes) {
        let history = this.getHistory();
        const workout = history.find(w => w.id === id);
        if (workout) {
          workout.notes = notes;
          this.saveHistory(history);
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          let history = this.getHistory();
          history = history.filter(w => w.id !== id);
          this.saveHistory(history);
          this.loadHistory();
      },
      
      // Modals
      closeAllModals() {
        document.querySelectorAll('#fortime_presetModal, #fortime_notesModal, #fortime_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) this.showCompletionModal();
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));
        if (workoutId) {
          this.updateWorkoutNotes(workoutId, notes);
        } else if (this.currentWorkout) {
          this.updateWorkoutNotes(this.currentWorkout.id, notes);
          this.currentWorkout.notes = notes;
        }
        this.closeAllModals();
        if (this.currentWorkout && !workoutId) {
          this.showCompletionModal();
        }
      },
      openNotesModal(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          this.els.workoutNotes.value = workout.notes || '';
          this.els.notesModal.setAttribute('data-workout-id', id);
          this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${t('final_time')}:</strong> ${this.formatTime(this.currentWorkout.finalTime)}</div>
          <div class="completion-stat"><strong>${this.currentWorkout.laps.length}</strong> Laps</div>
          ${this.currentWorkout.timeCap ? `<div class="completion-stat"><strong>Time Cap:</strong> ${this.currentWorkout.timeCap/60000} min</div>` : ''}
          `;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        this.els.workoutNotes.value = this.currentWorkout?.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', this.currentWorkout.id);
        this.els.notesModal.classList.add('active');
      },
      shareResult() {
        if (!this.currentWorkout) return;
        this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          const date = new Date(workout.date).toLocaleDateString();
          const timeCapText = workout.timeCap ? `\nTime Cap: ${workout.timeCap/60000}min` : '';
          const notesText = workout.notes ? `\n\nNotes: ${workout.notes}` : '';
          const text = t('share_text_fortime', {
            time: this.formatTime(workout.finalTime),
            lapsCount: workout.laps.length,
            date: date,
            timeCapText: timeCapText,
            notes: notesText
          });
          if (navigator.share) {
            navigator.share({ title: t('share_title_fortime'), text });
          } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
          }
      },
    };

       // === AMRAP APP LOGIC ===
    const AmrapApp = {
      // State
      duration: 600000, // 10 minutes in ms
      prepInterval: null, running: false, paused: false, inPrep: false,
      startTime: 0, pauseTime: 0, pausedDuration: 0, remainingTime: 600000,
      rounds: 0, animationFrameId: null,
      currentWorkout: null, editingPresetIndex: -1, initialized: false,
      workoutViewActive: false,
      lastAnnouncedSecond: null,
      midpointAnnounced: false,
      
      // DOM Elements
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.renderPresets();
        this.loadHistory();
        this.handleDurationChange(); // Initialize with default value
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'durationInput', 'status', 'prep', 'timer', 'startBtn', 'pauseBtn', 'resumeBtn', 'roundBtn', 'resetBtn', 'rounds', 'presetsContainer', 'addPresetBtn', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsList', 'historyList', 'totalWorkouts', 'totalRounds', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetDuration', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`amrap_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#amrap_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#amrap_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#amrap_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#amrap_presetModal [data-modal-close], #amrap_notesModal [data-modal-close], #amrap_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#amrap_presetModal [data-modal-cancel]');
        // Shared workout view elements
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutLapBtn = document.getElementById('workoutLapBtn'); // Reused for rounds
        this.els.workoutProgress = document.getElementById('workoutProgress');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyDuration(parseInt(btn.dataset.quick, 10))));
        this.els.durationInput.addEventListener('input', () => this.handleDurationChange());
        this.els.durationInput.addEventListener('blur', () => this.validateAmrapInputs());
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.roundBtn.addEventListener('click', () => this.addRound());
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;
            const { action, id, index } = target.dataset;
            switch(action) {
                case 'apply-preset': this.applyPreset(parseInt(index, 10)); break;
                case 'delete-preset': e.stopPropagation(); if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10)); break;
                case 'edit-preset': this.openPresetModal(parseInt(index, 10)); break;
                case 'clear-history': this.clearHistory(); break;
                case 'export-history': this.exportHistory(); break;
                case 'edit-history': this.openNotesModal(parseInt(id, 10)); break;
                case 'share-history': this.shareWorkout(parseInt(id, 10)); break;
                case 'delete-history': if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10)); break;
            }
        });
         // Event listeners para la vista de entrenamiento
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && AmrapApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && AmrapApp.running) this.handleWorkoutPause() });
        this.els.workoutLapBtn.addEventListener('click', () => { if(this.workoutViewActive && AmrapApp.running) this.addRound()});
      },

      validateAmrapInputs() {
        let val = parseInt(this.els.durationInput.value, 10);
        if (isNaN(val) || val <= 0) {
            this.els.durationInput.value = 10;
        } else {
            this.els.durationInput.value = val;
        }
        this.handleDurationChange();
      },

      updateLanguage() {
        this.updateUI();
        this.renderPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `amrap_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderPresets();
      },
      
      applyDuration(minutes) {
        if (isNaN(minutes)) return;
        this.els.durationInput.value = minutes;
        this.handleDurationChange();
      },

      handleDurationChange() {
        const val = this.els.durationInput.value.trim();
        const minutes = val ? parseInt(val, 10) : 10; // Default to 10 if empty
        this.duration = minutes * 60 * 1000;
        if(this.els.quickBtns) {
             this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === minutes));
        }
        if (!this.running) {
          this.remainingTime = this.duration;
          this.updateUI();
        }
      },

      formatTime(ms) {
        const totalSeconds = Math.ceil(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      },

      updateUI() {
        this.els.timer.textContent = this.formatTime(this.remainingTime);
        this.els.rounds.textContent = `${t('completed_rounds')} ${this.rounds}`;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },

      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        this.resetAll();
        this.handleDurationChange();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.running = true;
          this.startTime = performance.now();
          this.pausedDuration = 0;
          this.animationFrameId = requestAnimationFrame(() => this.tick());
          this.setStatus('training', 'running');
          this.els.startBtn.disabled = true;
          this.els.pauseBtn.disabled = false;
          this.els.roundBtn.disabled = false;
          this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
          this.openWorkoutView();
        });
      },

      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) { clearInterval(this.prepInterval); this.prepInterval = null; }
        this.setStatus('paused', 'paused');
        releaseWakeLock();
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = false;
        this.els.roundBtn.disabled = true;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.setStatus('training', 'running');
        this.els.pauseBtn.disabled = false;
        this.els.resumeBtn.disabled = true;
        this.els.roundBtn.disabled = false;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },

      addRound() {
        if (!this.running || this.paused) return;
        this.rounds++;
        this.updateUI();
        beepShort();
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false; this.inPrep = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        releaseWakeLock();
        this.remainingTime = this.duration; 
        this.rounds = 0; 
        this.pausedDuration = 0;
        this.lastAnnouncedSecond = null;
        this.midpointAnnounced = false;
        this.els.prep.style.display = 'none'; 
        this.els.timer.style.display = 'block';
        this.setStatus('ready', 'idle');
        this.els.startBtn.disabled = false;
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.roundBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
        this.updateUI();
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.inPrep = true;
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        this.setStatus('preparing', 'ready');
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval); this.prepInterval = null;
            ring();
            setTimeout(() => {
              this.inPrep = false;
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },
      
      tick() {
        if (!this.running || this.paused) return;
        const elapsedTime = performance.now() - this.startTime - this.pausedDuration;
        this.remainingTime = this.duration - elapsedTime;
        
        if (this.remainingTime <= 0) {
          this.remainingTime = 0;
          this.updateUI();
          this.completeWorkout();
          return;
        }

        if (!this.midpointAnnounced && elapsedTime >= (this.duration / 2)) {
            ring();
            this.midpointAnnounced = true;
        }

        const secondsRemaining = Math.ceil(this.remainingTime / 1000);
        if (secondsRemaining <= 5 && secondsRemaining > 0) {
          if (this.lastAnnouncedSecond !== secondsRemaining) {
            beepShort();
            this.lastAnnouncedSecond = secondsRemaining;
          }
        }

        this.updateUI();
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      completeWorkout() {
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        releaseWakeLock();
        this.setStatus('workout_complete_status', 'completed');
        victoryBells();
        this.saveWorkout({ rounds: this.rounds, duration: this.duration });
        this.closeWorkoutView();
        setTimeout(() => this.els.notesModal.classList.add('active'), 1000);
      },

      openWorkoutView() {
        this.workoutViewActive = true;
        document.getElementById('workoutStatus').style.display = 'none';
        document.getElementById('workoutLapsList').parentElement.style.display = 'none';
        this.els.workoutLapBtn.style.display = 'inline-block';
        this.els.workoutProgress.style.display = 'block';
        this.els.workoutTimer.classList.add('fortime');
        this.els.workoutTimer.style.fontFamily = 'monospace';
        
        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden';
        this.updateWorkoutView();
      },

      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = '';
      },

      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        
        this.els.workoutTimer.textContent = this.formatTime(this.remainingTime);
        this.els.workoutProgress.textContent = `${t('completed_rounds')} ${this.rounds}`;
        
        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        
        this.els.workoutLapBtn.textContent = t('round');
        this.els.workoutPauseBtn.disabled = !this.running;
        this.els.workoutLapBtn.disabled = !this.running || this.paused;
      },

      handleWorkoutPause() {
        if (!this.running) return;
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },

      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },
      
      // Presets
      getPresets() { return JSON.parse(localStorage.getItem('amrap_presets') || '[]'); },
      savePresets(presets) { localStorage.setItem('amrap_presets', JSON.stringify(presets)); },
      renderPresets() {
        const presets = this.getPresets();
        this.els.presetsContainer.innerHTML = '';
        presets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">Ã—</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          const presets = this.getPresets();
          if (!presets[index]) return;
          const preset = presets[index];
          this.applyDuration(preset.duration);
      },
      deletePreset(index) {
          let presets = this.getPresets();
          presets.splice(index, 1);
          this.savePresets(presets);
          this.renderPresets();
      },
      loadPresetsList() {
        const presets = this.getPresets();
        if (presets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets_amrap')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = presets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${t('workout_duration')} ${p.duration} min</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        const presets = this.getPresets();
        if (index > -1 && presets[index]) {
          const p = presets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title_amrap');
          this.els.presetName.value = p.name;
          this.els.presetDuration.value = p.duration;
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title_amrap');
          this.els.presetName.value = '';
          this.els.presetDuration.value = this.duration / 60000;
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const duration = this.els.presetDuration.value ? parseInt(this.els.presetDuration.value) : null;
        if (!name || !duration || duration <= 0) { alert(t('alert_fill_fields')); return; }
        
        const presets = this.getPresets();
        const newPreset = { name, duration };

        if (this.editingPresetIndex > -1) {
          presets[this.editingPresetIndex] = newPreset;
        } else {
          presets.push(newPreset);
        }
        this.savePresets(presets);
        this.renderPresets();
        this.closeAllModals();
      },
      
      // History
      getHistory() { return JSON.parse(localStorage.getItem('amrap_history') || '[]'); },
      saveHistory(history) { localStorage.setItem('amrap_history', JSON.stringify(history)); },
      loadHistory() {
        const history = this.getHistory();
        this.els.totalWorkouts.textContent = history.length;
        this.els.totalRounds.textContent = history.reduce((sum, w) => sum + (w.rounds || 0), 0);
        if (history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history_amrap')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = history.map(w => {
          const date = new Date(w.date);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} â€¢ ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${w.rounds} Rounds</div>
            <div class="history-details">${w.duration / 60000}min AMRAP</div>
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      exportHistory() {
        const history = this.getHistory();
        if (history.length === 0) return;
        const head = ['date', 'durationMinutes', 'completedRounds', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          w.duration / 60000,
          w.rounds,
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'amrap_history.csv');
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          this.saveHistory([]);
          this.loadHistory();
        }
      },
      saveWorkout(data, notes = '') {
        const workout = { id: Date.now(), date: new Date().toISOString(), ...data, notes };
        let history = this.getHistory();
        history.unshift(workout);
        if (history.length > 50) history.pop();
        this.saveHistory(history);
        this.currentWorkout = workout;
        this.loadHistory();
      },
      updateWorkoutNotes(id, notes) {
        let history = this.getHistory();
        const workout = history.find(w => w.id === id);
        if (workout) {
          workout.notes = notes;
          this.saveHistory(history);
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          let history = this.getHistory();
          history = history.filter(w => w.id !== id);
          this.saveHistory(history);
          this.loadHistory();
      },
      
      // Modals
      closeAllModals() {
        document.querySelectorAll('#amrap_presetModal, #amrap_notesModal, #amrap_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) this.showCompletionModal();
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));
        if (workoutId) {
          this.updateWorkoutNotes(workoutId, notes);
        } else if (this.currentWorkout) {
          this.updateWorkoutNotes(this.currentWorkout.id, notes);
          this.currentWorkout.notes = notes;
        }
        this.closeAllModals();
        if (this.currentWorkout && !workoutId) {
          this.showCompletionModal();
        }
      },
      openNotesModal(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          this.els.workoutNotes.value = workout.notes || '';
          this.els.notesModal.setAttribute('data-workout-id', id);
          this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${t('completed_rounds')}:</strong> ${this.currentWorkout.rounds}</div>
          <div class="completion-stat"><strong>${t('workout_duration')}:</strong> ${this.currentWorkout.duration/60000} min</div>
          `;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        this.els.workoutNotes.value = this.currentWorkout?.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', this.currentWorkout.id);
        this.els.notesModal.classList.add('active');
      },
      shareResult() {
        if (!this.currentWorkout) return;
        this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          const date = new Date(workout.date).toLocaleDateString();
          const notesText = workout.notes ? `\n\nNotes: ${workout.notes}` : '';
          const text = t('share_text_amrap', {
            rounds: workout.rounds,
            duration: workout.duration / 60000,
            date: date,
            notes: notesText
          });
          if (navigator.share) {
            navigator.share({ title: t('share_title_amrap'), text });
          } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
          }
      },
    };


    // === GLOBAL INITIALIZATION ===
    document.addEventListener('DOMContentLoaded', () => {
      // Settings Listeners
      document.getElementById('languageSelect').addEventListener('change', function() {
        currentLanguage = this.value;
        localStorage.setItem('timer_pro_language', currentLanguage);
        updateAllAppsLanguage();
      });
      document.getElementById('themeSelect').addEventListener('change', function() {
        document.documentElement.setAttribute('data-theme', this.value === 'light' ? 'light' : null);
        localStorage.setItem('timer_pro_theme', this.value);
      });
      document.getElementById('volumeSlider').addEventListener('input', function() {
        ensureAudioContext().then(() => {
            if (masterGain) {
                masterGain.gain.value = this.value;
            }
        });
        localStorage.setItem('timer_pro_volume', this.value);
      });
      document.getElementById('wakeLockToggle').addEventListener('click', function() {
        this.classList.toggle('active');
        localStorage.setItem('timer_pro_wakeLock', this.classList.contains('active'));
      });

      // Load settings
      const savedLang = localStorage.getItem('timer_pro_language') || navigator.language.split('-')[0];
      if (translations[savedLang]) {
          currentLanguage = savedLang;
      }
      document.getElementById('languageSelect').value = currentLanguage;
      
      const savedTheme = localStorage.getItem('timer_pro_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme === 'light' ? 'light' : null);
      document.getElementById('themeSelect').value = savedTheme;
      
      const savedVolume = localStorage.getItem('timer_pro_volume');
      document.getElementById('volumeSlider').value = savedVolume !== null ? parseFloat(savedVolume) : 0.8;
      
      const wakeLockEnabled = localStorage.getItem('timer_pro_wakeLock') !== 'false';
      document.getElementById('wakeLockToggle').classList.toggle('active', wakeLockEnabled);
      
      // Initialize
      updateAllAppsLanguage();
      showPage('home');

      // Add a listener to release wake lock when page is not visible
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          releaseWakeLock();
        } else if (document.visibilityState === 'visible' && 
                  (EmomApp.running && !EmomApp.paused || 
                   TabataApp.running && !TabataApp.paused || 
                   ForTimeApp.running && !ForTimeApp.paused ||
                   AmrapApp.running && !AmrapApp.paused)) {
          requestWakeLock();
        }
      });
    });
  