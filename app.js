
    const translations = {
      es: {
        brand_title: "Timer Pro",
        back_menu: "← Volver al menú",
        landing_title: "Elige tu temporizador",
        landing_subtitle: "Selecciona el tipo de entrenamiento que quieres realizar",
        emom_desc: "Every Minute On the Minute - Completa tu trabajo cada minuto",
        tabata_desc: "20s trabajo, 10s descanso - Intervalos de alta intensidad",
        for_time_desc: "Completa el trabajo lo más rápido posible",
        amrap_desc: "As Many Rounds As Possible - Tantas rondas como puedas",
        settings: "Configuración",
        appearance: "Apariencia",
        theme: "Tema",
        theme_night: "Noche",
        theme_day: "Día",
        audio_settings: "Audio",
        volume: "Volumen",
        display: "Pantalla",
        keep_screen_on: "Mantener pantalla encendida",
        tab_timer: "Cronómetro",
        tab_presets: "Presets",
        tab_history: "Historial",
        new_preset: "Nuevo Preset",
        custom_presets: "Presets Personalizados",
        workout_history: "Historial de Entrenamientos",
        clear_all: "Limpiar Todo",
        export_csv: "Exportar CSV",
        total_workouts: "Entrenamientos Totales",
        total_cycles: "Ciclos Totales",
        ready: "Listo",
        preparing: "Preparando…",
        paused: "Pausado",
        start: "Empezar",
        stop: "Detener",
        pause: "Pausar",
        resume: "Continuar",
        reset: "Reiniciar",
        lap: "Lap",
        round: "Round",
        completed_cycles: "Ciclos completados:",
        progress: "Progreso:",
        donate_paypal: "Donar vía PayPal",
        cancel: "Cancelar",
        save: "Guardar",
        skip: "Omitir",
        save_notes: "Guardar Notas",
        workout_complete: "🎉 ¡Entrenamiento Completado!",
        share_result: "Compartir Resultado",
        add_notes: "Agregar Notas",
        close: "Cerrar",
        edit: "Editar",
        share: "Compartir",
        delete: "Eliminar",
        how_did_it_feel: "¿Cómo te sentiste? (RPE, notas, etc.)",
        emom_app_title: "Cronómetro EMOM Pro",
        seconds_per_cycle: "Segundos por ciclo:",
        target_cycles: "Ciclos objetivo:",
        leave_empty_unlimited: "(dejar vacío para ilimitado)",
        training: "¡Entrenando!",
        workout_complete_status: "🚨 ¡ENTRENAMIENTO COMPLETO! 🚨",
        support_text: "Construido con amor para la comunidad EMOM. Si quieres apoyar mi trabajo, una pequeña donación ayuda mucho.",
        presets_description: "Crea y gestiona tus presets EMOM personalizados",
        no_presets: "¡Aún no hay presets personalizados. Haz clic en 'Nuevo Preset' para crear uno!",
        no_history: "¡Aún no hay entrenamientos completados. Completa un objetivo para ver tu historial aquí!",
        new_preset_title: "Nuevo Preset",
        edit_preset_title: "Editar Preset",
        preset_name: "Nombre del Preset",
        preset_name_placeholder: "ej. EMOM Pesado, Quema Rápida",
        seconds_per_cycle_short: "Segundos por ciclo",
        target_cycles_short: "Ciclos objetivo",
        optional: "Opcional",
        workout_notes: "Notas del Entrenamiento",
        notes_placeholder: "ej. RPE 8/10, me sentí fuerte, buena forma durante todo el entrenamiento...",
        tabata_app_title: "Cronómetro Tabata Pro",
        support_text_tabata: "Construido con amor para la comunidad Tabata. Si quieres apoyar mi trabajo, una pequeña donación ayuda mucho.",
        presets_description_tabata: "Crea y gestiona tus presets Tabata personalizados",
        no_presets_tabata: "No hay presets personalizados aún. ¡Haz clic en 'Nuevo Preset' para crear uno!",
        no_history_tabata: "No hay entrenamientos completados aún. ¡Completa una sesión para ver tu historial aquí!",
        work_seconds: "Trabajo (s):",
        rest_seconds: "Descanso (s):",
        cycles: "Ciclos:",
        work_seconds_short: "Segundos de trabajo",
        rest_seconds_short: "Segundos de descanso",
        new_preset_title_tabata: "Nuevo Preset",
        edit_preset_title_tabata: "Editar Preset",
        preset_name_placeholder_tabata: "ej. Tabata Intenso, Quema Grasa",
        workout_notes_tabata: "Notas del Entrenamiento",
        notes_placeholder_tabata: "ej. RPE 8/10, me sentí fuerte, buena forma durante todo el entrenamiento...",
        status_work: "¡Trabaja!",
        status_rest: "Descansa",
        confirm_delete_preset: "¿Eliminar este preset?",
        confirm_delete_history: "¿Eliminar este entrenamiento del historial?",
        confirm_clear_history: "¿Estás seguro de que quieres borrar todo el historial?",
        alert_fill_fields: "Por favor completa todos los campos",
        alert_copied: "¡Resultado copiado al portapapeles!",
        share_title_tabata: "¡Entrenamiento Tabata Completado!",
        share_text_tabata: "¡Tabata Completado! 💪\n{cycles} ciclos • {work}s/{rest}s\n{duration}min entrenamiento el {date}{notes}",
        share_text_emom: "¡EMOM Completado! 💪\n{cycles} ciclos × {seconds}s\n{duration}min entrenamiento el {date}{notes}",
        minutes_total: "minutos de entrenamiento total",
        fortime_app_title: "Cronómetro For Time Pro",
        time_cap: "Time Cap (min):",
        time_cap_minutes: "Time Cap (minutos)",
        new_preset_title_fortime: "Nuevo Preset For Time",
        edit_preset_title_fortime: "Editar Preset For Time",
        preset_name_placeholder_fortime: "ej. Fran, Murph",
        presets_description_fortime: "Crea y gestiona tus presets For Time personalizados.",
        no_presets_fortime: "No hay presets personalizados. ¡Crea uno!",
        no_history_fortime: "Aún no hay entrenamientos. ¡Completa uno para verlo aquí!",
        workout_notes_fortime: "Notas del Entrenamiento",
        notes_placeholder_fortime: "ej. RPE 9/10, tiempo récord, mejorar transiciones...",
        support_text_fortime: "Construido con amor para la comunidad For Time. Si quieres apoyar mi trabajo, una pequeña donación ayuda mucho.",
        total_laps: "Laps Totales",
        final_time: "Tiempo Final",
        share_title_fortime: "¡Entrenamiento For Time Completado!",
        share_text_fortime: "¡For Time Completado! 🚀\nTiempo: {time}\n{lapsCount} Laps el {date}{timeCapText}{notes}",
        expand_view: "Expandir vista de entrenamiento",
        amrap_app_title: "Cronómetro AMRAP Pro",
        workout_duration: "Duración (min):",
        total_rounds: "Rondas Totales",
        completed_rounds: "Rondas completadas:",
        presets_description_amrap: "Crea y gestiona tus presets AMRAP personalizados.",
        no_presets_amrap: "No hay presets personalizados. ¡Crea uno!",
        no_history_amrap: "Aún no hay entrenamientos. ¡Completa uno para verlo aquí!",
        new_preset_title_amrap: "Nuevo Preset AMRAP",
        edit_preset_title_amrap: "Editar Preset AMRAP",
        preset_name_placeholder_amrap: "ej. Cindy, Chelsea",
        workout_notes_amrap: "Notas del Entrenamiento",
        notes_placeholder_amrap: "ej. RPE 9/10, ritmo constante, mejorar transiciones...",
        support_text_amrap: "Construido con amor para la comunidad AMRAP. Si quieres apoyar mi trabajo, una pequeña donación ayuda mucho.",
        share_title_amrap: "¡Entrenamiento AMRAP Completado! 🔄\n{rounds} Rondas en {duration}min\nel {date}{notes}",
      },
      en: {
        brand_title: "Timer Pro",
        back_menu: "← Back to menu",
        landing_title: "Choose your timer",
        landing_subtitle: "Select the type of workout you want to perform",
        emom_desc: "Every Minute On the Minute - Complete your work every minute",
        tabata_desc: "20s work, 10s rest - High intensity intervals",
        for_time_desc: "Complete the work as fast as possible",
        amrap_desc: "As Many Rounds As Possible - As many rounds as you can",
        settings: "Settings",
        appearance: "Appearance",
        theme: "Theme",
        theme_night: "Night",
        theme_day: "Day",
        audio_settings: "Audio",
        volume: "Volume",
        display: "Display",
        keep_screen_on: "Keep screen on during workout",
        tab_timer: "Timer",
        tab_presets: "Presets",
        tab_history: "History",
        new_preset: "New Preset",
        custom_presets: "Custom Presets",
        workout_history: "Workout History",
        clear_all: "Clear All",
        export_csv: "Export CSV",
        total_workouts: "Total Workouts",
        total_cycles: "Total Cycles",
        ready: "Ready",
        preparing: "Preparing…",
        paused: "Paused",
        start: "Start",
        stop: "Stop",
        pause: "Pause",
        resume: "Resume",
        reset: "Reset",
        lap: "Lap",
        round: "Round",
        completed_cycles: "Completed cycles:",
        progress: "Progress:",
        donate_paypal: "Donate via PayPal",
        cancel: "Cancel",
        save: "Save",
        skip: "Skip",
        save_notes: "Save Notes",
        workout_complete: "🎉 Workout Complete!",
        share_result: "Share Result",
        add_notes: "Add Notes",
        close: "Close",
        edit: "Edit",
        share: "Share",
        delete: "Delete",
        how_did_it_feel: "How did it feel? (RPE, notes, etc.)",
        emom_app_title: "EMOM Timer Pro",
        seconds_per_cycle: "Seconds per cycle:",
        target_cycles: "Target cycles:",
        leave_empty_unlimited: "(leave empty for unlimited)",
        training: "Training!",
        workout_complete_status: "🚨 WORKOUT COMPLETE! 🚨",
        support_text: "Built with love for the EMOM community. If you want to support my work, a small donation goes a long way.",
        presets_description: "Create and manage your custom EMOM presets",
        no_presets: "No custom presets yet. Click 'New Preset' to create one!",
        no_history: "No completed workouts yet. Complete a target to see your history here!",
        new_preset_title: "New Preset",
        edit_preset_title: "Edit Preset",
        preset_name: "Preset Name",
        preset_name_placeholder: "e.g., Heavy EMOM, Quick Burn",
        seconds_per_cycle_short: "Seconds per cycle",
        target_cycles_short: "Target cycles",
        optional: "Optional",
        workout_notes: "Workout Notes",
        notes_placeholder: "e.g., RPE 8/10, felt strong, good form throughout...",
        tabata_app_title: "Tabata Timer Pro",
        support_text_tabata: "Built with love for the Tabata community. If you want to support my work, a small donation goes a long way.",
        presets_description_tabata: "Create and manage your custom Tabata presets",
        no_presets_tabata: "No custom presets yet. Click 'New Preset' to create one!",
        no_history_tabata: "No completed workouts yet. Complete a session to see your history here!",
        work_seconds: "Work (s):",
        rest_seconds: "Rest (s):",
        cycles: "Cycles:",
        work_seconds_short: "Work seconds",
        rest_seconds_short: "Rest seconds",
        new_preset_title_tabata: "New Preset",
        edit_preset_title_tabata: "Edit Preset",
        preset_name_placeholder_tabata: "e.g., Intense Tabata, Fat Burn",
        workout_notes_tabata: "Workout Notes",
        notes_placeholder_tabata: "e.g., RPE 8/10, felt strong, good form throughout...",
        status_work: "Work!",
        status_rest: "Rest",
        confirm_delete_preset: "Delete this preset?",
        confirm_delete_history: "Delete this workout from history?",
        confirm_clear_history: "Are you sure you want to clear all history?",
        alert_fill_fields: "Please fill all fields",
        alert_copied: "Result copied to clipboard!",
        share_title_tabata: "Tabata Workout Complete!",
        share_text_tabata: "Tabata Completed! 💪\n{cycles} cycles • {work}s/{rest}s\n{duration}min workout on {date}{notes}",
        share_text_emom: "EMOM Completed! 💪\n{cycles} cycles × {seconds}s\n{duration}min workout on {date}{notes}",
        minutes_total: "minutes total workout",
        fortime_app_title: "For Time Timer Pro",
        time_cap: "Time Cap (min):",
        time_cap_minutes: "Time Cap (minutes)",
        new_preset_title_fortime: "New For Time Preset",
        edit_preset_title_fortime: "Edit For Time Preset",
        preset_name_placeholder_fortime: "e.g. Fran, Murph",
        presets_description_fortime: "Create and manage your custom For Time presets.",
        no_presets_fortime: "No custom presets yet. Create one!",
        no_history_fortime: "No workouts yet. Complete one to see it here!",
        workout_notes_fortime: "Workout Notes",
        notes_placeholder_fortime: "e.g. RPE 9/10, record time, improve transitions...",
        support_text_fortime: "Built with love for the For Time community. If you want to support my work, a small donation goes a long way.",
        total_laps: "Total Laps",
        final_time: "Final Time",
        share_title_fortime: "For Time Workout Complete!",
        share_text_fortime: "For Time Completed! 🚀\nTime: {time}\n{lapsCount} Laps on {date}{timeCapText}{notes}",
        expand_view: "Expand workout view",
        amrap_app_title: "AMRAP Timer Pro",
        workout_duration: "Duration (min):",
        total_rounds: "Total Rounds",
        completed_rounds: "Completed Rounds:",
        presets_description_amrap: "Create and manage your custom AMRAP presets.",
        no_presets_amrap: "No custom presets yet. Create one!",
        no_history_amrap: "No workouts yet. Complete one to see it here!",
        new_preset_title_amrap: "New AMRAP Preset",
        edit_preset_title_amrap: "Edit AMRAP Preset",
        preset_name_placeholder_amrap: "e.g. Cindy, Chelsea",
        workout_notes_amrap: "Workout Notes",
        notes_placeholder_amrap: "e.g. RPE 9/10, consistent pace, improve transitions...",
        support_text_amrap: "Built with love for the AMRAP community. If you want to support my work, a small donation helps a lot.",
        share_title_amrap: "AMRAP Workout Complete!",
        share_text_amrap: "AMRAP Completed! 🔄\n{rounds} Rounds in {duration}min\non {date}{notes}",
      },
      de: {
        brand_title: "Timer Pro",
        back_menu: "← Zurück zum Menü",
        landing_title: "Wählen Sie Ihren Timer",
        landing_subtitle: "Wählen Sie die Art des Trainings, das Sie durchführen möchten",
        emom_desc: "Every Minute On the Minute - Schließen Sie Ihre Arbeit jede Minute ab",
        tabata_desc: "20s Arbeit, 10s Pause - Hochintensive Intervalle",
        for_time_desc: "Schließen Sie die Arbeit so schnell wie möglich ab",
        amrap_desc: "As Many Rounds As Possible - So viele Runden wie möglich",
        settings: "Einstellungen",
        appearance: "Aussehen",
        theme: "Thema",
        theme_night: "Nacht",
        theme_day: "Tag",
        audio_settings: "Audio",
        volume: "Lautstärke",
        display: "Anzeige",
        keep_screen_on: "Bildschirm während des Trainings eingeschaltet lassen",
        tab_timer: "Timer",
        tab_presets: "Presets",
        tab_history: "Verlauf",
        new_preset: "Neues Preset",
        custom_presets: "Benutzerdefinierte Presets",
        workout_history: "Trainings-Verlauf",
        clear_all: "Alle löschen",
        export_csv: "CSV Exportieren",
        total_workouts: "Gesamte Trainings",
        total_cycles: "Gesamte Zyklen",
        ready: "Bereit",
        preparing: "Vorbereitung…",
        paused: "Pausiert",
        start: "Start",
        stop: "Stopp",
        pause: "Pause",
        resume: "Fortsetzen",
        reset: "Zurücksetzen",
        lap: "Runde",
        round: "Runde",
        completed_cycles: "Abgeschlossene Zyklen:",
        progress: "Fortschritt:",
        donate_paypal: "Über PayPal spenden",
        cancel: "Abbrechen",
        save: "Speichern",
        skip: "Überspringen",
        save_notes: "Notizen speichern",
        workout_complete: "🎉 Training abgeschlossen!",
        share_result: "Ergebnis teilen",
        add_notes: "Notizen hinzufügen",
        close: "Schließen",
        edit: "Bearbeiten",
        share: "Teilen",
        delete: "Löschen",
        how_did_it_feel: "Wie hat es sich angefühlt? (RPE, Notizen, etc.)",
        emom_app_title: "EMOM Timer Pro",
        seconds_per_cycle: "Sekunden pro Zyklus:",
        target_cycles: "Ziel-Zyklen:",
        leave_empty_unlimited: "(leer lassen für unbegrenzt)",
        training: "Training!",
        workout_complete_status: "🚨 TRAINING ABGESCHLOSSEN! 🚨",
        support_text: "Mit Liebe für die EMOM-Community erstellt. Wenn Sie meine Arbeit unterstützen möchten, hilft eine kleine Spende sehr.",
        presets_description: "Erstellen und verwalten Sie Ihre benutzerdefinierten EMOM-Presets",
        no_presets: "Noch keine benutzerdefinierten Presets. Klicken Sie auf 'Neues Preset', um eines zu erstellen!",
        no_history: "Noch keine abgeschlossenen Trainings. Schließen Sie ein Ziel ab, um Ihren Verlauf hier zu sehen!",
        new_preset_title: "Neues Preset",
        edit_preset_title: "Preset bearbeiten",
        preset_name: "Preset-Name",
        preset_name_placeholder: "z.B. Schweres EMOM, Schneller Brand",
        seconds_per_cycle_short: "Sekunden pro Zyklus",
        target_cycles_short: "Ziel-Zyklen",
        optional: "Optional",
        workout_notes: "Trainings-Notizen",
        notes_placeholder: "z.B. RPE 8/10, fühlte mich stark, gute Form durchgehend...",
        tabata_app_title: "Tabata Timer Pro",
        support_text_tabata: "Mit Liebe für die Tabata-Community erstellt. Wenn Sie meine Arbeit unterstützen möchten, hilft eine kleine Spende sehr.",
        presets_description_tabata: "Erstellen und verwalten Sie Ihre benutzerdefinierten Tabata-Presets",
        no_presets_tabata: "Noch keine benutzerdefinierten Presets. Klicken Sie auf 'Neues Preset', um eines zu erstellen!",
        no_history_tabata: "Noch keine abgeschlossenen Trainings. Schließen Sie eine Sitzung ab, um Ihren Verlauf hier zu sehen!",
        work_seconds: "Arbeit (s):",
        rest_seconds: "Pause (s):",
        cycles: "Zyklen:",
        work_seconds_short: "Arbeitssekunden",
        rest_seconds_short: "Pausensekunden",
        new_preset_title_tabata: "Neues Preset",
        edit_preset_title_tabata: "Preset bearbeiten",
        preset_name_placeholder_tabata: "z.B. Intensives Tabata, Fettverbrennung",
        workout_notes_tabata: "Trainings-Notizen",
        notes_placeholder_tabata: "z.B. RPE 8/10, fühlte mich stark, gute Form durchgehend...",
        status_work: "Arbeit!",
        status_rest: "Pause",
        confirm_delete_preset: "Dieses Preset löschen?",
        confirm_delete_history: "Dieses Training aus dem Verlauf löschen?",
        confirm_clear_history: "Sind Sie sicher, dass Sie den gesamten Verlauf löschen möchten?",
        alert_fill_fields: "Bitte füllen Sie alle Felder aus",
        alert_copied: "Ergebnis in die Zwischenablage kopiert!",
        share_title_tabata: "Tabata Training abgeschlossen!",
        share_text_tabata: "Tabata abgeschlossen! 💪\n{cycles} Zyklen • {work}s/{rest}s\n{duration}min Training am {date}{notes}",
        share_text_emom: "EMOM abgeschlossen! 💪\n{cycles} Zyklen × {seconds}s\n{duration}min Training am {date}{notes}",
        minutes_total: "Minuten Gesamttraining",
        fortime_app_title: "For Time Timer Pro",
        time_cap: "Zeitlimit (min):",
        time_cap_minutes: "Zeitlimit (Minuten)",
        new_preset_title_fortime: "Neues For Time Preset",
        edit_preset_title_fortime: "For Time Preset bearbeiten",
        preset_name_placeholder_fortime: "z.B. Fran, Murph",
        presets_description_fortime: "Erstellen und verwalten Sie Ihre benutzerdefinierten For Time Presets.",
        no_presets_fortime: "Noch keine Presets. Erstellen Sie eines!",
        no_history_fortime: "Noch keine Trainings. Schließen Sie eines ab, um es hier zu sehen!",
        workout_notes_fortime: "Trainingsnotizen",
        notes_placeholder_fortime: "z.B. RPE 9/10, Rekordzeit, Übergänge verbessern...",
        support_text_fortime: "Mit Liebe für die For Time-Community erstellt. Wenn Sie meine Arbeit unterstützen möchten, hilft eine kleine Spende sehr.",
        total_laps: "Gesamte Runden",
        final_time: "Endzeit",
        share_title_fortime: "For Time Training abgeschlossen!",
        share_text_fortime: "For Time abgeschlossen! 🚀\nZeit: {time}\n{lapsCount} Runden am {date}{timeCapText}{notes}",
        expand_view: "Trainingsansicht erweitern",
        amrap_app_title: "AMRAP Timer Pro",
        workout_duration: "Dauer (min):",
        total_rounds: "Gesamte Runden",
        completed_rounds: "Abgeschlossene Runden:",
        presets_description_amrap: "Erstellen und verwalten Sie Ihre benutzerdefinierten AMRAP-Presets.",
        no_presets_amrap: "Noch keine Presets. Erstellen Sie eines!",
        no_history_amrap: "Noch keine Trainings. Schließen Sie eines ab, um es hier zu sehen!",
        new_preset_title_amrap: "Neues AMRAP Preset",
        edit_preset_title_amrap: "AMRAP Preset bearbeiten",
        preset_name_placeholder_amrap: "z.B. Cindy, Chelsea",
        workout_notes_amrap: "Trainingsnotizen",
        notes_placeholder_amrap: "z.B. RPE 9/10, konstantes Tempo, Übergänge verbessern...",
        support_text_amrap: "Mit Liebe für die AMRAP-Community erstellt. Wenn Sie meine Arbeit unterstützen möchten, hilft eine kleine Spende sehr.",
        share_title_amrap: "AMRAP Training abgeschlossen!",
        share_text_amrap: "AMRAP abgeschlossen! 🔄\n{rounds} Runden in {duration}min\nam {date}{notes}",
      },
      fr: {
        brand_title: "Timer Pro",
        back_menu: "← Retour au menu",
        landing_title: "Choisissez votre minuteur",
        landing_subtitle: "Sélectionnez le type d'entraînement que vous souhaitez effectuer",
        emom_desc: "Every Minute On the Minute - Terminez votre travail chaque minute",
        tabata_desc: "20s travail, 10s repos - Intervalles haute intensité",
        for_time_desc: "Terminez le travail le plus rapidement possible",
        amrap_desc: "As Many Rounds As Possible - Autant de tours que possible",
        settings: "Paramètres",
        appearance: "Apparence",
        theme: "Thème",
        theme_night: "Nuit",
        theme_day: "Jour",
        audio_settings: "Audio",
        volume: "Volume",
        display: "Affichage",
        keep_screen_on: "Garder l'écran allumé pendant l'entraînement",
        tab_timer: "Minuteur",
        tab_presets: "Préréglages",
        tab_history: "Historique",
        new_preset: "Nouveau Préréglage",
        custom_presets: "Préréglages Personnalisés",
        workout_history: "Historique des Entraînements",
        clear_all: "Tout effacer",
        export_csv: "Exporter CSV",
        total_workouts: "Entraînements Totaux",
        total_cycles: "Cycles Totaux",
        ready: "Prêt",
        preparing: "Préparation…",
        paused: "En pause",
        start: "Commencer",
        stop: "Arrêter",
        pause: "Pause",
        resume: "Reprendre",
        reset: "Réinitialiser",
        lap: "Tour",
        round: "Round",
        completed_cycles: "Cycles terminés :",
        progress: "Progrès :",
        donate_paypal: "Faire un don via PayPal",
        cancel: "Annuler",
        save: "Sauvegarder",
        skip: "Ignorer",
        save_notes: "Sauvegarder les Notes",
        workout_complete: "🎉 Entraînement Terminé !",
        share_result: "Partager le Résultat",
        add_notes: "Ajouter des Notes",
        close: "Fermer",
        edit: "Modifier",
        share: "Partager",
        delete: "Supprimer",
        how_did_it_feel: "Comment vous êtes-vous senti ? (RPE, notes, etc.)",
        emom_app_title: "Minuteur EMOM Pro",
        seconds_per_cycle: "Secondes par cycle :",
        target_cycles: "Cycles cibles :",
        leave_empty_unlimited: "(laisser vide pour illimité)",
        training: "Entraînement !",
        workout_complete_status: "🚨 ENTRAÎNEMENT TERMINÉ ! 🚨",
        support_text: "Construit avec amour pour la communauté EMOM. Si vous voulez soutenir mon travail, un petit don aide beaucoup.",
        presets_description: "Créez et gérez vos préréglages EMOM personnalisés",
        no_presets: "Aucun préréglage personnalisé pour le moment. Cliquez sur 'Nouveau Préréglage' pour en créer un !",
        no_history: "Aucun entraînement terminé pour le moment. Terminez un objectif pour voir votre historique ici !",
        new_preset_title: "Nouveau Préréglage",
        edit_preset_title: "Modifier le Préréglage",
        preset_name: "Nom du Préréglage",
        preset_name_placeholder: "ex. EMOM Lourd, Brûlage Rapide",
        seconds_per_cycle_short: "Secondes par cycle",
        target_cycles_short: "Cycles cibles",
        optional: "Optionnel",
        workout_notes: "Notes d'Entraînement",
        notes_placeholder: "ex. RPE 8/10, je me sentais fort, bonne forme tout au long...",
        tabata_app_title: "Minuteur Tabata Pro",
        support_text_tabata: "Construit avec amour pour la communauté Tabata. Si vous voulez soutenir mon travail, un petit don aide beaucoup.",
        presets_description_tabata: "Créez et gérez vos préréglages Tabata personnalisés",
        no_presets_tabata: "Aucun préréglage personnalisé pour le moment. Cliquez sur 'Nouveau Préréglage' pour en créer un !",
        no_history_tabata: "Aucun entraînement terminé pour le moment. Terminez une session pour voir votre historique ici !",
        work_seconds: "Travail (s) :",
        rest_seconds: "Repos (s) :",
        cycles: "Cycles :",
        work_seconds_short: "Secondes de travail",
        rest_seconds_short: "Secondes de repos",
        new_preset_title_tabata: "Nouveau Préréglage",
        edit_preset_title_tabata: "Modifier le Préréglage",
        preset_name_placeholder_tabata: "ex. Tabata Intense, Brûle-Graisse",
        workout_notes_tabata: "Notes d'Entraînement",
        notes_placeholder_tabata: "ex. RPE 8/10, je me sentais fort, bonne forme tout au long...",
        status_work: "Travaillez !",
        status_rest: "Repos",
        confirm_delete_preset: "Supprimer ce préréglage ?",
        confirm_delete_history: "Supprimer cet entraînement de l'historique ?",
        confirm_clear_history: "Êtes-vous sûr de vouloir effacer tout l'historique ?",
        alert_fill_fields: "Veuillez remplir tous les champs",
        alert_copied: "Résultat copié dans le presse-papiers !",
        share_title_tabata: "Entraînement Tabata Terminé !",
        share_text_tabata: "Tabata Terminé ! 💪\n{cycles} cycles • {work}s/{rest}s\n{duration}min d'entraînement le {date}{notes}",
        share_text_emom: "EMOM Terminé ! 💪\n{cycles} cycles × {seconds}s\n{duration}min d'entraînement le {date}{notes}",
        minutes_total: "minutes d'entraînement au total",
        fortime_app_title: "Minuteur For Time Pro",
        time_cap: "Temps max (min):",
        time_cap_minutes: "Temps max (minutes)",
        new_preset_title_fortime: "Nouveau Préréglage For Time",
        edit_preset_title_fortime: "Modifier Préréglage For Time",
        preset_name_placeholder_fortime: "ex. Fran, Murph",
        presets_description_fortime: "Créez et gérez vos préréglages For Time personnalisés.",
        no_presets_fortime: "Aucun préréglage. Créez-en un !",
        no_history_fortime: "Aucun entraînement. Terminez-en un pour le voir ici !",
        workout_notes_fortime: "Notes d'entraînement",
        notes_placeholder_fortime: "ex. RPE 9/10, temps record, améliorer les transitions...",
        support_text_fortime: "Construit avec amour pour la communauté For Time. Si vous voulez soutenir mon travail, un petit don aide beaucoup.",
        total_laps: "Tours Totaux",
        final_time: "Temps Final",
        share_title_fortime: "Entraînement For Time Terminé !",
        share_text_fortime: "For Time Terminé ! 🚀\nTemps: {time}\n{lapsCount} Tours le {date}{timeCapText}{notes}",
        expand_view: "Agrandir la vue de l'entraînement",
        amrap_app_title: "Minuteur AMRAP Pro",
        workout_duration: "Durée (min) :",
        total_rounds: "Tours totaux",
        completed_rounds: "Tours terminés :",
        presets_description_amrap: "Créez et gérez vos préréglages AMRAP personnalisés.",
        no_presets_amrap: "Aucun préréglage pour le moment. Créez-en un !",
        no_history_amrap: "Aucun entraînement pour le moment. Terminez-en un pour le voir ici !",
        new_preset_title_amrap: "Nouveau Préréglage AMRAP",
        edit_preset_title_amrap: "Modifier Préréglage AMRAP",
        preset_name_placeholder_amrap: "ex: Cindy, Chelsea",
        workout_notes_amrap: "Notes d'entraînement",
        notes_placeholder_amrap: "ex: RPE 9/10, rythme constant, améliorer les transitions...",
        support_text_amrap: "Construit avec amour pour la communauté AMRAP. Si vous voulez soutenir mon travail, un petit don est le bienvenu.",
        share_title_amrap: "Entraînement AMRAP Terminé !",
        share_text_amrap: "AMRAP Terminé ! 🔄\n{rounds} Tours en {duration}min\nle {date}{notes}",
      },
      it: {
        "brand_title": "Timer Pro",
        "back_menu": "← Torna al menu",
        "landing_title": "Scegli il tuo timer",
        "landing_subtitle": "Seleziona il tipo di allenamento che vuoi eseguire",
        "emom_desc": "Every Minute On the Minute - Completa il tuo lavoro ogni minuto",
        "tabata_desc": "20s lavoro, 10s riposo - Intervalli ad alta intensità",
        "for_time_desc": "Completa il lavoro il più velocemente possibile",
        "amrap_desc": "As Many Rounds As Possible - Quanti più round possibili",
        "settings": "Impostazioni",
        "appearance": "Aspetto",
        "theme": "Tema",
        "theme_night": "Notte",
        "theme_day": "Giorno",
        "audio_settings": "Audio",
        "volume": "Volume",
        "display": "Schermo",
        "keep_screen_on": "Mantieni lo schermo acceso durante l'allenamento",
        "tab_timer": "Timer",
        "tab_presets": "Preset",
        "tab_history": "Cronologia",
        "new_preset": "Nuovo Preset",
        "custom_presets": "Preset Personalizzati",
        "workout_history": "Cronologia Allenamenti",
        "clear_all": "Cancella Tutto",
        "export_csv": "Esporta CSV",
        "total_workouts": "Allenamenti Totali",
        "total_cycles": "Cicli Totali",
        "ready": "Pronto",
        "preparing": "Preparazione…",
        "paused": "In pausa",
        "start": "Inizia",
        "stop": "Ferma",
        "pause": "Pausa",
        "resume": "Riprendi",
        "reset": "Ripristina",
        "lap": "Giro",
        "round": "Round",
        "completed_cycles": "Cicli completati:",
        "progress": "Progresso:",
        "donate_paypal": "Dona tramite PayPal",
        "cancel": "Annulla",
        "save": "Salva",
        "skip": "Salta",
        "save_notes": "Salva Note",
        "workout_complete": "🎉 Allenamento Completato!",
        "share_result": "Condividi Risultato",
        "add_notes": "Aggiungi Note",
        "close": "Chiudi",
        "edit": "Modifica",
        "share": "Condividi",
        "delete": "Elimina",
        "how_did_it_feel": "Come ti sei sentito? (RPE, note, etc.)",
        "emom_app_title": "Timer EMOM Pro",
        "seconds_per_cycle": "Secondi per ciclo:",
        "target_cycles": "Cicli obiettivo:",
        "leave_empty_unlimited": "(lascia vuoto per illimitato)",
        "training": "Allenamento!",
        "workout_complete_status": "🚨 ALLENAMENTO COMPLETATO! 🚨",
        "support_text": "Costruito con amore per la comunità EMOM. Se vuoi supportare il mio lavoro, una piccola donazione aiuta molto.",
        "presets_description": "Crea e gestisci i tuoi preset EMOM personalizzati",
        "no_presets": "Nessun preset personalizzato ancora. Clicca 'Nuovo Preset' per crearne uno!",
        "no_history": "Nessun allenamento completato ancora. Completa un obiettivo per vedere la tua cronologia qui!",
        "new_preset_title": "Nuovo Preset",
        "edit_preset_title": "Modifica Preset",
        "preset_name": "Nome Preset",
        "preset_name_placeholder": "es. EMOM Pesante, Brucia Veloce",
        "seconds_per_cycle_short": "Secondi per ciclo",
        "target_cycles_short": "Cicli obiettivo",
        "optional": "Opzionale",
        "workout_notes": "Note Allenamento",
        "notes_placeholder": "es. RPE 8/10, mi sono sentito forte, buona forma durante tutto...",
        "tabata_app_title": "Timer Tabata Pro",
        "support_text_tabata": "Costruito con amore per la comunità Tabata. Se vuoi supportare il mio lavoro, una piccola donazione aiuta molto.",
        "presets_description_tabata": "Crea e gestisci i tuoi preset Tabata personalizzati",
        "no_presets_tabata": "Nessun preset personalizzato ancora. Clicca 'Nuovo Preset' per crearne uno!",
        "no_history_tabata": "Nessun allenamento completato ancora. Completa una sessione per vedere la tua cronologia qui!",
        "work_seconds": "Lavoro (s):",
        "rest_seconds": "Riposo (s):",
        "cycles": "Cicli:",
        "work_seconds_short": "Secondi di lavoro",
        "rest_seconds_short": "Secondi di riposo",
        "new_preset_title_tabata": "Nuovo Preset",
        "edit_preset_title_tabata": "Modifica Preset",
        "preset_name_placeholder_tabata": "es. Tabata Intenso, Brucia Grassi",
        "workout_notes_tabata": "Note Allenamento",
        "notes_placeholder_tabata": "es. RPE 8/10, mi sono sentito forte, buona forma durante tutto...",
        "status_work": "Lavora!",
        "status_rest": "Riposo",
        "confirm_delete_preset": "Eliminare questo preset?",
        "confirm_delete_history": "Eliminare questo allenamento dalla cronologia?",
        "confirm_clear_history": "Sei sicuro di voler cancellare tutta la cronologia?",
        "alert_fill_fields": "Per favore, compila tutti i campi",
        "alert_copied": "Risultato copiato negli appunti!",
        "share_title_tabata": "Allenamento Tabata Completato!",
        "share_text_tabata": "Tabata Completato! 💪\n{cycles} cicli • {work}s/{rest}s\n{duration}min allenamento il {date}{notes}",
        "share_text_emom": "EMOM Completato! 💪\n{cycles} cicli × {seconds}s\n{duration}min allenamento il {date}{notes}",
        "minutes_total": "minuti di allenamento totale",
        "fortime_app_title": "Timer For Time Pro",
        "time_cap": "Time Cap (min):",
        "time_cap_minutes": "Time Cap (minuti)",
        "new_preset_title_fortime": "Nuovo Preset For Time",
        "edit_preset_title_fortime": "Modifica Preset For Time",
        "preset_name_placeholder_fortime": "es. Fran, Murph",
        "presets_description_fortime": "Crea e gestisci i tuoi preset For Time personalizzati.",
        "no_presets_fortime": "Nessun preset. Creane uno!",
        "no_history_fortime": "Nessun allenamento. Completane uno per vederlo qui!",
        "workout_notes_fortime": "Note Allenamento",
        "notes_placeholder_fortime": "es. RPE 9/10, tempo record, migliorare transizioni...",
        "support_text_fortime": "Costruito con amore per la comunità For Time. Se vuoi supportare il mio lavoro, una piccola donazione aiuta molto.",
        "total_laps": "Giri Totali",
        "final_time": "Tempo Finale",
        "share_title_fortime": "Allenamento For Time Completato!",
        "share_text_fortime": "For Time Completato! 🚀\nTempo: {time}\n{lapsCount} Giri il {date}{timeCapText}{notes}",
        "expand_view": "Espandi la vista allenamento",
        "amrap_app_title": "Timer AMRAP Pro",
        "workout_duration": "Durata (min):",
        "total_rounds": "Round totali",
        "completed_rounds": "Round completati:",
        "presets_description_amrap": "Crea e gestisci i tuoi preset AMRAP personalizzati.",
        "no_presets_amrap": "Nessun preset ancora. Creane uno!",
        "no_history_amrap": "Nessun allenamento ancora. Completane uno per vederlo qui!",
        "new_preset_title_amrap": "Nuovo Preset AMRAP",
        "edit_preset_title_amrap": "Modifica Preset AMRAP",
        "preset_name_placeholder_amrap": "es. Cindy, Chelsea",
        "workout_notes_amrap": "Note allenamento",
        "notes_placeholder_amrap": "es. RPE 9/10, ritmo costante, migliorare le transizioni...",
        "support_text_amrap": "Costruito con amore per la comunità AMRAP. Se vuoi sostenere il mio lavoro, una piccola donazione aiuta molto.",
        "share_title_amrap": "Allenamento AMRAP completato!",
        "share_text_amrap": "AMRAP completato! 🔄\n{rounds} Round in {duration}min\nil {date}{notes}",
      },
      pt: {
        "brand_title": "Timer Pro",
        "back_menu": "← Voltar ao menu",
        "landing_title": "Escolha seu cronômetro",
        "landing_subtitle": "Selecione o tipo de treino que deseja realizar",
        "emom_desc": "Every Minute On the Minute - Complete seu trabalho a cada minuto",
        "tabata_desc": "20s trabalho, 10s descanso - Intervalos de alta intensidade",
        "for_time_desc": "Complete o trabalho o mais rápido possível",
        "amrap_desc": "As Many Rounds As Possible - Quantas rounds conseguir",
        "settings": "Configurações",
        "appearance": "Aparência",
        "theme": "Tema",
        "theme_night": "Noite",
        "theme_day": "Dia",
        "audio_settings": "Áudio",
        "volume": "Volume",
        "display": "Tela",
        "keep_screen_on": "Manter tela ligada durante o treino",
        "tab_timer": "Cronômetro",
        "tab_presets": "Presets",
        "tab_history": "Histórico",
        "new_preset": "Novo Preset",
        "custom_presets": "Presets Personalizados",
        "workout_history": "Histórico de Treinos",
        "clear_all": "Limpar Tudo",
        "export_csv": "Exportar CSV",
        "total_workouts": "Treinos Totais",
        "total_cycles": "Ciclos Totais",
        "ready": "Pronto",
        "preparing": "Preparando…",
        "paused": "Pausado",
        "start": "Iniciar",
        "stop": "Parar",
        "pause": "Pausar",
        "resume": "Continuar",
        "reset": "Reiniciar",
        "lap": "Volta",
        "round": "Round",
        "completed_cycles": "Ciclos completados:",
        "progress": "Progresso:",
        "donate_paypal": "Doar via PayPal",
        "cancel": "Cancelar",
        "save": "Salvar",
        "skip": "Pular",
        "save_notes": "Salvar Notas",
        "workout_complete": "🎉 Treino Concluído!",
        "share_result": "Compartilhar Resultado",
        "add_notes": "Adicionar Notas",
        "close": "Fechar",
        "edit": "Editar",
        "share": "Compartilhar",
        "delete": "Deletar",
        "how_did_it_feel": "Como você se sentiu? (RPE, notas, etc.)",
        "emom_app_title": "Cronómetro EMOM Pro",
        "seconds_per_cycle": "Segundos por ciclo:",
        "target_cycles": "Ciclos alvo:",
        "leave_empty_unlimited": "(deixar vazio para ilimitado)",
        "training": "Treinando!",
        "workout_complete_status": "🚨 TREINO COMPLETO! 🚨",
        "support_text": "Construído com amor para a comunidade EMOM. Se você quer apoiar meu trabalho, uma pequena doação ajuda muito.",
        "presets_description": "Crie e gerencie seus presets EMOM personalizados",
        "no_presets": "Nenhum preset personalizado ainda. Clique em 'Novo Preset' para criar um!",
        "no_history": "Nenhum treino completado ainda. Complete um objetivo para ver seu histórico aqui!",
        "new_preset_title": "Novo Preset",
        "edit_preset_title": "Editar Preset",
        "preset_name": "Nome do Preset",
        "preset_name_placeholder": "ex. EMOM Pesado, Queima Rápida",
        "seconds_per_cycle_short": "Segundos por ciclo",
        "target_cycles_short": "Ciclos alvo",
        "optional": "Opcional",
        "workout_notes": "Notas do Treino",
        "notes_placeholder": "ex. RPE 8/10, me senti forte, boa forma durante todo...",
        "tabata_app_title": "Cronômetro Tabata Pro",
        "support_text_tabata": "Construído com amor para a comunidade Tabata. Se você quer apoiar meu trabalho, uma pequena doação ajuda muito.",
        "presets_description_tabata": "Crie e gerencie seus presets Tabata personalizados",
        "no_presets_tabata": "Nenhum preset personalizado ainda. Clique em 'Novo Preset' para criar um!",
        "no_history_tabata": "Nenhum treino completado ainda. Complete uma sessão para ver seu histórico aqui!",
        "work_seconds": "Trabalho (s):",
        "rest_seconds": "Descanso (s):",
        "cycles": "Ciclos:",
        "work_seconds_short": "Segundos de trabalho",
        "rest_seconds_short": "Segundos de descanso",
        "new_preset_title_tabata": "Novo Preset",
        "edit_preset_title_tabata": "Editar Preset",
        "preset_name_placeholder_tabata": "ex. Tabata Intenso, Queima Gordura",
        "workout_notes_tabata": "Notas do Treino",
        "notes_placeholder_tabata": "ex. RPE 8/10, me senti forte, boa forma durante todo...",
        "status_work": "Trabalhe!",
        "status_rest": "Descanse",
        "confirm_delete_preset": "Deletar este preset?",
        "confirm_delete_history": "Deletar este treino do histórico?",
        "confirm_clear_history": "Tem certeza que quer limpar todo o histórico?",
        "alert_fill_fields": "Por favor, preencha todos os campos",
        "alert_copied": "Resultado copiado para a área de transferência!",
        "share_title_tabata": "Treino de Tabata Concluído!",
        "share_text_tabata": "Tabata Concluído! 💪\n{cycles} ciclos • {work}s/{rest}s\n{duration}min de treino em {date}{notes}",
        "share_text_emom": "EMOM Concluído! 💪\n{cycles} ciclos × {seconds}s\n{duration}min de treino em {date}{notes}",
        "minutes_total": "minutos de treino total",
        "fortime_app_title": "Cronômetro For Time Pro",
        "time_cap": "Time Cap (min):",
        "time_cap_minutes": "Time Cap (minutos)",
        "new_preset_title_fortime": "Novo Preset For Time",
        "edit_preset_title_fortime": "Editar Preset For Time",
        "preset_name_placeholder_fortime": "ex. Fran, Murph",
        "presets_description_fortime": "Crie e gerencie seus presets For Time personalizados.",
        "no_presets_fortime": "Nenhum preset. Crie um!",
        "no_history_fortime": "Nenhum treino ainda. Complete um para vê-lo aqui!",
        "workout_notes_fortime": "Notas do Treino",
        "notes_placeholder_fortime": "ex. RPE 9/10, tempo recorde, mejorar transições...",
        "support_text_fortime": "Construído com amor para la comunidade For Time. Se você quer apoiar meu trabalho, uma pequena doação ajuda muito.",
        "total_laps": "Voltas Totais",
        "final_time": "Tempo Final",
        "share_title_fortime": "Treino For Time Concluído!",
        "share_text_fortime": "For Time Concluído! 🚀\nTempo: {time}\n{lapsCount} Voltas em {date}{timeCapText}{notes}",
        "expand_view": "Expandir visualização do treino",
        "amrap_app_title": "Cronômetro AMRAP Pro",
        "workout_duration": "Duração (min):",
        "total_rounds": "Rounds Totais",
        "completed_rounds": "Rounds completados:",
        "presets_description_amrap": "Crie e gerencie seus presets AMRAP personalizados.",
        "no_presets_amrap": "Nenhum preset ainda. Crie um!",
        "no_history_amrap": "Nenhum treino ainda. Complete um para vê-lo aqui!",
        "new_preset_title_amrap": "Novo Preset AMRAP",
        "edit_preset_title_amrap": "Editar Preset AMRAP",
        "preset_name_placeholder_amrap": "ex. Cindy, Chelsea",
        "workout_notes_amrap": "Notas do Treino",
        "notes_placeholder_amrap": "ex. RPE 9/10, ritmo consistente, melhorar transições...",
        "support_text_amrap": "Construído com amor para a comunidade AMRAP. Se você quer apoiar meu trabalho, uma pequena doação ajuda muito.",
        "share_title_amrap": "Treino AMRAP Concluído!",
        "share_text_amrap": "AMRAP Concluído! 🔄\n{rounds} Rounds em {duration}min\nem {date}{notes}",
      },
      zh: {
        "brand_title": "计时器专业版",
        "back_menu": "← 返回菜单",
        "landing_title": "选择您的计时器",
        "landing_subtitle": "选择您要进行的训练类型",
        "emom_desc": "Every Minute On the Minute - 每分钟完成您的工作",
        "tabata_desc": "20秒工作，10秒休息 - 高强度间歇",
        "for_time_desc": "尽快完成工作",
        "amrap_desc": "As Many Rounds As Possible - 尽可能多的轮数",
        "settings": "设置",
        "appearance": "外观",
        "theme": "主题",
        "theme_night": "夜间",
        "theme_day": "日间",
        "audio_settings": "音频",
        "volume": "音量",
        "display": "显示",
        "keep_screen_on": "训练时保持屏幕常亮",
        "tab_timer": "计时器",
        "tab_presets": "预设",
        "tab_history": "历史记录",
        "new_preset": "新预设",
        "custom_presets": "自定义预设",
        "workout_history": "训练历史",
        "clear_all": "清空全部",
        "export_csv": "导出 CSV",
        "total_workouts": "总训练次数",
        "total_cycles": "总循环数",
        "ready": "准备就绪",
        "preparing": "准备中…",
        "paused": "已暂停",
        "start": "开始",
        "stop": "停止",
        "pause": "暂停",
        "resume": "继续",
        "reset": "重置",
        "lap": "计圈",
        "round": "计次",
        "completed_cycles": "已完成循环：",
        "progress": "进度：",
        "donate_paypal": "通过 PayPal 捐赠",
        "cancel": "取消",
        "save": "保存",
        "skip": "跳过",
        "save_notes": "保存备注",
        "workout_complete": "🎉 训练完成！",
        "share_result": "分享结果",
        "add_notes": "添加备注",
        "close": "关闭",
        "edit": "编辑",
        "share": "分享",
        "delete": "删除",
        "how_did_it_feel": "感觉如何？（RPE、备注等）",
        "emom_app_title": "EMOM 计时器专业版",
        "seconds_per_cycle": "每循环秒数：",
        "target_cycles": "目标循环：",
        "leave_empty_unlimited": "（留空为无限制）",
        "training": "训练中！",
        "workout_complete_status": "🚨 训练完成！🚨",
        "support_text": "为 EMOM 社区用心打造。如果您想支持我的工作，小额捐赠将大有帮助。",
        "presets_description": "创建和管理您的自定义 EMOM 预设",
        "no_presets": "还没有自定义预设。点击'新预设'创建一个！",
        "no_history": "还没有完成的训练。完成一个目标即可在此查看您的历史记录！",
        "new_preset_title": "新预设",
        "edit_preset_title": "编辑预设",
        "preset_name": "预设名称",
        "preset_name_placeholder": "例如：重量 EMOM，快速燃烧",
        "seconds_per_cycle_short": "每循环秒数",
        "target_cycles_short": "目标循环",
        "optional": "可选",
        "workout_notes": "训练备注",
        "notes_placeholder": "例如：RPE 8/10，感觉很强壮，全程动作标准...",
        "tabata_app_title": "Tabata 计时器专业版",
        "support_text_tabata": "为 Tabata 社区用心打造。如果您想支持我的工作，小额捐赠将大有帮助。",
        "presets_description_tabata": "创建和管理您的自定义 Tabata 预设",
        "no_presets_tabata": "还没有自定义预设。点击'新预设'创建一个！",
        "no_history_tabata": "还没有完成的训练。完成一个训练即可在此查看您的历史记录！",
        "work_seconds": "工作（秒）：",
        "rest_seconds": "休息（秒）：",
        "cycles": "循环：",
        "work_seconds_short": "工作秒数",
        "rest_seconds_short": "休息秒数",
        "new_preset_title_tabata": "新预设",
        "edit_preset_title_tabata": "编辑预设",
        "preset_name_placeholder_tabata": "例如：高强度 Tabata，燃脂训练",
        "workout_notes_tabata": "训练备注",
        "notes_placeholder_tabata": "例如：RPE 8/10，感觉很强壮，全程动作标准...",
        "status_work": "开始！",
        "status_rest": "休息",
        "confirm_delete_preset": "删除此预设？",
        "confirm_delete_history": "从历史记录中删除此训练？",
        "confirm_clear_history": "确定要清除所有历史记录吗？",
        "alert_fill_fields": "请填写所有字段",
        "alert_copied": "结果已复制到剪贴板！",
        "share_title_tabata": "Tabata 训练完成！",
        "share_text_tabata": "Tabata 完成！💪\n{cycles} 次循环 • {work}秒/{rest}秒\n{duration}分钟训练于 {date}{notes}",
        "share_text_emom": "EMOM 完成！💪\n{cycles} 次循环 × {seconds}秒\n{duration}分钟训练于 {date}{notes}",
        "minutes_total": "分钟总训练时间",
        "fortime_app_title": "For Time 计时器专业版",
        "time_cap": "时间上限 (分钟):",
        "time_cap_minutes": "时间上限 (分钟)",
        "new_preset_title_fortime": "新建 For Time 预设",
        "edit_preset_title_fortime": "编辑 For Time 预设",
        "preset_name_placeholder_fortime": "例如：Fran, Murph",
        "presets_description_fortime": "创建和管理您的自定义 For Time 预设。",
        "no_presets_fortime": "尚无预设。创建一个吧！",
        "no_history_fortime": "尚无训练记录。完成一次训练即可在此查看！",
        "workout_notes_fortime": "训练备注",
        "notes_placeholder_fortime": "例如：RPE 9/10，创下纪录，改进转换...",
        "support_text_fortime": "为 For Time 社区用心打造。如果您想支持我的工作，小额捐赠将大有帮助。",
        "total_laps": "总计圈数",
        "final_time": "最终时间",
        "share_title_fortime": "For Time 训练完成！",
        "share_text_fortime": "For Time 完成！🚀\n时间: {time}\n{lapsCount} 圈于 {date}{timeCapText}{notes}",
        "expand_view": "展开训练视图",
        "amrap_app_title": "AMRAP 计时器专业版",
        "workout_duration": "训练时长 (分钟):",
        "total_rounds": "总轮数",
        "completed_rounds": "已完成轮数:",
        "presets_description_amrap": "创建和管理您的自定义 AMRAP 预设。",
        "no_presets_amrap": "尚无自定义预设。创建一个吧！",
        "no_history_amrap": "尚无训练记录。完成一次即可在此查看！",
        "new_preset_title_amrap": "新建 AMRAP 预设",
        "edit_preset_title_amrap": "编辑 AMRAP 预设",
        "preset_name_placeholder_amrap": "例如: Cindy, Chelsea",
        "workout_notes_amrap": "训练备注",
        "notes_placeholder_amrap": "例如: RPE 9/10, 节奏稳定, 改进转换...",
        "support_text_amrap": "为 AMRAP 社区用心打造。如果您想支持我的工作，小额捐赠将大有帮助。",
        "share_title_amrap": "AMRAP 训练完成！",
        "share_text_amrap": "AMRAP 完成！🔄\n{rounds} 轮在 {duration}分钟内\n于 {date}{notes}",
      }
    };

    // === GLOBAL APP CONTROLLER ===
    let currentLanguage = 'es';
    let wakeLock = null;
    let audioCtx = null;
    let masterGain = null;

    function t(key, replacements = {}) {
      let translation = translations[currentLanguage]?.[key] || translations['en']?.[key] || key;
      for (const placeholder in replacements) {
        translation = translation.replace(`{${placeholder}}`, replacements[placeholder]);
      }
      return translation;
    }

    function translatePage() {
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            const span = el.querySelector('span');
            if (span && el.classList.contains('add-preset')) {
                // Handle complex button like "+ New Preset"
                const textNode = Array.from(el.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
                if(textNode) textNode.textContent = t(key);
                const spanWithText = el.querySelector('span[data-i18n]');
                if (spanWithText) spanWithText.textContent = t(spanWithText.dataset.i18n);

            } else {
               el.textContent = t(key);
            }
        });
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            el.placeholder = t(key);
        });
        document.querySelectorAll('[data-i18n-title]').forEach(el => {
            const key = el.getAttribute('data-i18n-title');
            el.title = t(key);
        });
        const themeOptions = document.querySelectorAll('#themeSelect option');
        themeOptions.forEach(option => {
            const key = option.getAttribute('data-i18n');
            if (key) option.textContent = t(key);
        });
    }

    function updateAllAppsLanguage() {
      translatePage();
      if(EmomApp.initialized) EmomApp.updateLanguage();
      if(TabataApp.initialized) TabataApp.updateLanguage();
      if(ForTimeApp.initialized) ForTimeApp.updateLanguage();
      if(AmrapApp.initialized) AmrapApp.updateLanguage();
    }
    
    function showPage(pageId) {
      document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
      const pageToShow = document.getElementById(pageId);
      if(pageToShow) pageToShow.classList.add('active');
      
      const backBtn = document.getElementById('backBtn');
      const logo = document.querySelector('.header .logo');
      if (pageId === 'home') {
        logo.style.display = 'block';
        backBtn.style.display = 'none';
        if(EmomApp.initialized) EmomApp.resetAll();
        if(TabataApp.initialized) TabataApp.resetAll();
        if(ForTimeApp.initialized) ForTimeApp.resetAll();
        if(AmrapApp.initialized) AmrapApp.resetAll();
      } else {
        logo.style.display = 'none';
        backBtn.style.display = 'flex';
        if (pageId === 'emom') EmomApp.init();
        else if (pageId === 'tabata') TabataApp.init();
        else if (pageId === 'fortime') ForTimeApp.init();
        else if (pageId === 'amrap') AmrapApp.init();
      }
    }

    function openSettings() {
      document.getElementById('settingsModal').classList.add('active');
    }

    function closeSettings() {
      document.getElementById('settingsModal').classList.remove('active');
    }
    
    // === AUDIO SYSTEM ===
    async function ensureAudioContext() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { console.error("AudioContext not supported"); return; }
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume().catch(() => {});
      }
      if (!masterGain && audioCtx) {
        masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);
        const savedVolume = localStorage.getItem('timer_pro_volume');
        masterGain.gain.value = savedVolume !== null ? parseFloat(savedVolume) : 0.8;
      }
      return audioCtx;
    }

    function playTone({ freq = 440, duration = 0.2, type = 'sine', volume = 0.8 }) {
      ensureAudioContext().then(ctx => {
        if(!ctx || !masterGain) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(volume, ctx.currentTime + 0.01);
        gain.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + duration - 0.02);
        osc.connect(gain); gain.connect(masterGain);
        osc.start(); osc.stop(ctx.currentTime + duration + 0.01);
        osc.onended = () => { try { osc.disconnect(); gain.disconnect(); } catch (e) { } };
      }).catch(() => { });
    }

    function playSiren({ startFreq = 800, endFreq = 1400, duration = 0.5, type = 'square', volume = 1.0 }) {
      ensureAudioContext().then(ctx => {
        if(!ctx || !masterGain) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(endFreq, ctx.currentTime + duration);
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(volume, ctx.currentTime + 0.02);
        gain.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + duration - 0.02);
        osc.connect(gain); gain.connect(masterGain);
        osc.start(); osc.stop(ctx.currentTime + duration + 0.01);
        osc.onended = () => { try { osc.disconnect(); gain.disconnect(); } catch (e) { } };
      }).catch(() => { });
    }
    function beepShort() { playTone({ freq: 1000, duration: 0.18, type: 'square', volume: 0.95 }); }
    function beepPrep() { playTone({ freq: 800, duration: 0.22, type: 'sine', volume: 0.95 }); }
    function ring() {
      playTone({ freq: 1200, duration: 0.25, type: 'square', volume: 1.0 });
      setTimeout(() => playTone({ freq: 1200, duration: 0.25, type: 'square', volume: 1.0 }), 300);
      setTimeout(() => playTone({ freq: 1200, duration: 0.4, type: 'square', volume: 1.0 }), 600);
    }
    function victoryBells() {
      let t = 0;
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          playSiren({ startFreq: 600, endFreq: 1200, duration: 0.25, type: 'square', volume: 1.0 });
          playSiren({ startFreq: 700, endFreq: 1400, duration: 0.25, type: 'sawtooth', volume: 0.9 });
        }, t);
        t += 280;
        setTimeout(() => {
          playSiren({ startFreq: 1200, endFreq: 600, duration: 0.25, type: 'square', volume: 1.0 });
          playSiren({ startFreq: 1400, endFreq: 700, duration: 0.25, type: 'sawtooth', volume: 0.9 });
        }, t);
        t += 280;
      }
      setTimeout(() => {
        playSiren({ startFreq: 400, endFreq: 2000, duration: 0.8, type: 'square', volume: 1.0 });
        playSiren({ startFreq: 500, endFreq: 1800, duration: 0.8, type: 'sawtooth', volume: 0.95 });
        setTimeout(() => playTone({ freq: 2400, duration: 0.4, type: 'square', volume: 0.8 }), 200);
      }, t + 200);
    }
    
    // === WAKE LOCK ===
    async function requestWakeLock() {
      if (document.getElementById('wakeLockToggle').classList.contains('active') && 'wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (e) { console.log('WakeLock request failed'); }
      }
    }
    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release().then(() => { wakeLock = null; });
      }
    }

    // === HELPERS ===
    function downloadCSV(csvContent, filename) {
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // === EMOM APP LOGIC ===
    const EmomApp = {
      // State
      cycleSeconds: 60, targetCycles: null, prepInterval: null, running: false,
      paused: false, inPrep: false, remaining: 60, cycles: 0, lastAnnouncedSecond: null,
      startTime: 0, pauseTime: 0, pausedDuration: 0, animationFrameId: null,
      currentWorkout: null, editingPresetIndex: -1, initialized: false, workoutViewActive: false,
      
      // DOM Elements
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.loadSettingsFromLocalStorage();
        this.renderPresets();
        this.loadHistory();
        this.updateUI();
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'secInput', 'targetInput', 'status', 'prep', 'timer', 'startBtn', 'pauseBtn', 'resumeBtn', 'resetBtn', 'cycles', 'progress', 'presetsContainer', 'addPresetBtn', 'quick', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsList', 'historyList', 'totalWorkouts', 'totalCycles', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetSeconds', 'presetCycles', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`emom_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#emom_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#emom_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#emom_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#emom_presetModal [data-modal-close], #emom_notesModal [data-modal-close], #emom_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#emom_presetModal [data-modal-cancel]');
         // Shared workout view elements
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutProgress = document.getElementById('workoutProgress');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyCycleSeconds(parseInt(btn.dataset.quick, 10))));
        this.els.secInput.addEventListener('input', () => this.handleSecInputTyping());
        this.els.secInput.addEventListener('blur', () => this.handleSecInputBlur());
        this.els.targetInput.addEventListener('input', () => this.handleTargetInputChange());
        this.els.targetInput.addEventListener('blur', () => {
            const val = parseInt(this.els.targetInput.value, 10);
            if (val <= 0) {
                this.els.targetInput.value = '';
                this.handleTargetInputChange();
            } else if (!isNaN(val)) {
                this.els.targetInput.value = val;
                this.handleTargetInputChange();
            }
        });
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && EmomApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && EmomApp.running) this.handleWorkoutPause() });

        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;

            const { action, id, index } = target.dataset;

            switch(action) {
                case 'apply-preset':
                    this.applyPreset(parseInt(index, 10));
                    break;
                case 'delete-preset':
                    e.stopPropagation();
                    if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10));
                    break;
                case 'edit-preset':
                    this.openPresetModal(parseInt(index, 10));
                    break;
                case 'clear-history':
                    this.clearHistory();
                    break;
                case 'export-history':
                    this.exportHistory();
                    break;
                case 'edit-history':
                    this.openNotesModal(parseInt(id, 10));
                    break;
                case 'share-history':
                    this.shareWorkout(parseInt(id, 10));
                    break;
                case 'delete-history':
                    if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10));
                    break;
            }
        });
      },
      
      updateLanguage() {
        this.updateUI();
        this.renderPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `emom_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderPresets();
      },

      applyCycleSeconds(n) {
        if (isNaN(n)) return;
        this.cycleSeconds = Math.max(10, Math.min(999, n));
        this.els.secInput.value = this.cycleSeconds;
        this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === this.cycleSeconds));
        if (!this.running || this.paused) {
          this.remaining = this.cycleSeconds;
          this.updateUI();
        }
      },

      handleSecInputTyping() {
        let value = parseInt(this.els.secInput.value, 10);

        if (!isNaN(value)) {
            this.cycleSeconds = value;
            this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === this.cycleSeconds));
            if (!this.running || this.paused) {
                this.remaining = this.cycleSeconds;
                this.updateUI();
            }
        }
      },

      handleSecInputBlur() {
        let value = parseInt(this.els.secInput.value, 10);
        if (isNaN(value) || value < 10) {
            value = this.cycleSeconds > 10 ? this.cycleSeconds : 60; 
        }
        this.applyCycleSeconds(value);
      },

      handleTargetInputChange() {
        let value = this.els.targetInput.value.replace(/[^0-9]/g, '');
        this.targetCycles = value === '' ? null : parseInt(value, 10);
        this.updateUI();
      },
      
      updateUI() {
        this.els.timer.textContent = this.remaining;
        this.els.cycles.textContent = t('completed_cycles') + ' ' + this.cycles;
        if (this.targetCycles > 0) {
          this.els.progress.textContent = `${t('progress')} ${this.cycles}/${this.targetCycles}`;
          this.els.progress.style.color = this.cycles >= this.targetCycles ? 'var(--success)' : 'var(--muted-text)';
        } else {
          this.els.progress.textContent = '';
        }
        if(this.workoutViewActive) this.updateWorkoutView();
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },

      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        if (this.running && !this.paused) return;
        this.handleSecInputBlur(); // Ensure the value is validated before starting
        this.remaining = this.cycleSeconds;
        this.cycles = 0;
        this.updateUI();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.startCycleTick();
          this.openWorkoutView();
        });
        this.els.startBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
        this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
      },
      
      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = null;
        this.setStatus('paused', 'paused');
        releaseWakeLock();
        this.els.resumeBtn.disabled = false;
        this.els.startBtn.disabled = true;
        this.els.pauseBtn.disabled = true;
        this.updateUI();
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.setStatus('training', 'running');
        this.els.resumeBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false; this.inPrep = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.animationFrameId = null; this.prepInterval = null;
        releaseWakeLock();
        this.cycles = 0; 
        this.remaining = this.cycleSeconds; 
        this.els.prep.style.display = 'none'; 
        this.els.timer.style.display = 'block';
        this.setStatus('ready', 'idle');
        this.els.resumeBtn.disabled = true; 
        this.els.startBtn.disabled = false; 
        this.els.pauseBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
        this.updateUI();
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.inPrep = true;
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        this.setStatus('preparing', 'ready');
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval); this.prepInterval = null;
            ring();
            setTimeout(() => {
              this.inPrep = false;
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },
      
      startCycleTick() {
        this.setStatus('training', 'running');
        this.running = true; this.paused = false;
        this.startTime = performance.now();
        this.pausedDuration = 0;
        this.lastAnnouncedSecond = null;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      tick() {
        if (!this.running || this.paused || this.inPrep) return;

        const elapsedMs = performance.now() - this.startTime - this.pausedDuration;
        const cycleDurationMs = this.cycleSeconds * 1000;

        const newCycles = Math.floor(elapsedMs / cycleDurationMs);
        if (newCycles > this.cycles) {
          this.cycles = newCycles;
          ring();
          if (this.targetCycles && this.cycles >= this.targetCycles) {
            this.completeWorkout();
            return;
          }
        }
        
        const elapsedInCycle = elapsedMs % cycleDurationMs;
        const newRemaining = this.cycleSeconds - Math.floor(elapsedInCycle / 1000);

        if(this.remaining !== newRemaining) {
            this.remaining = newRemaining;
            this.updateUI();
        }

        if (this.remaining <= 5 && this.remaining > 0 && this.lastAnnouncedSecond !== this.remaining) {
          beepShort();
          this.lastAnnouncedSecond = this.remaining;
        } else if (this.remaining > 5) {
          this.lastAnnouncedSecond = null;
        }

        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      completeWorkout() {
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        releaseWakeLock();
        this.setStatus('workout_complete_status', 'completed');
        victoryBells();
        this.saveWorkout({ cycles: this.cycles, secondsPerCycle: this.cycleSeconds, totalTime: this.cycles * this.cycleSeconds });
        this.closeWorkoutView();
        setTimeout(() => this.els.notesModal.classList.add('active'), 1000);
        setTimeout(() => this.resetAll(), 1200);
      },

      // Workout View
      openWorkoutView() {
        this.workoutViewActive = true;
        // Configure for EMOM
        document.getElementById('workoutStatus').style.display = 'none';
        document.getElementById('workoutLapBtn').style.display = 'none';
        document.getElementById('workoutLapsList').parentElement.style.display = 'none';
        this.els.workoutProgress.style.display = 'block';
        this.els.workoutTimer.classList.remove('fortime');
        this.els.workoutTimer.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden';
        this.updateWorkoutView();
      },
      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = '';
      },
      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        this.els.workoutTimer.textContent = this.remaining;
        
        if (this.targetCycles > 0) {
          this.els.workoutProgress.textContent = `${t('cycles')} ${this.cycles}/${this.targetCycles}`;
        } else {
          this.els.workoutProgress.textContent = `${t('completed_cycles')} ${this.cycles}`;
        }

        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        this.els.workoutPauseBtn.disabled = !this.running;
      },
      handleWorkoutPause() {
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },
      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },
      
      // Presets
      getPresets() { return JSON.parse(localStorage.getItem('emom_presets') || '[]'); },
      savePresets(presets) { localStorage.setItem('emom_presets', JSON.stringify(presets)); },
      renderPresets() {
        const presets = this.getPresets();
        // Clear only the user presets, not the "add new" button if it were here
        this.els.presetsContainer.innerHTML = '';
        presets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">×</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          const presets = this.getPresets();
          if (!presets[index]) return;
          const preset = presets[index];
          this.applyCycleSeconds(preset.seconds);
          this.els.targetInput.value = preset.cycles || '';
          this.handleTargetInputChange();
      },
      deletePreset(index) {
          let presets = this.getPresets();
          presets.splice(index, 1);
          this.savePresets(presets);
          this.renderPresets();
      },
      loadPresetsList() {
        const presets = this.getPresets();
        if (presets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = presets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${p.seconds}s ${t('seconds_per_cycle_short')} ${p.cycles ? `• ${p.cycles} ${t('target_cycles_short')}`: `• ${t('leave_empty_unlimited')}`}</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        const presets = this.getPresets();
        if (index > -1 && presets[index]) {
          const p = presets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title');
          this.els.presetName.value = p.name;
          this.els.presetSeconds.value = p.seconds;
          this.els.presetCycles.value = p.cycles || '';
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title');
          this.els.presetName.value = '';
          this.els.presetSeconds.value = this.cycleSeconds;
          this.els.presetCycles.value = this.targetCycles || '';
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const seconds = parseInt(this.els.presetSeconds.value);
        const cycles = this.els.presetCycles.value ? parseInt(this.els.presetCycles.value) : null;
        if (!name || !seconds || seconds < 10) { alert(t('alert_fill_fields')); return; }
        
        const presets = this.getPresets();
        const newPreset = { name, seconds, cycles };

        if (this.editingPresetIndex > -1) {
          presets[this.editingPresetIndex] = newPreset;
        } else {
          presets.push(newPreset);
        }
        this.savePresets(presets);
        this.renderPresets();
        this.closeAllModals();
      },
      
      // History
      getHistory() { return JSON.parse(localStorage.getItem('emom_history') || '[]'); },
      saveHistory(history) { localStorage.setItem('emom_history', JSON.stringify(history)); },
      loadHistory() {
        const history = this.getHistory();
        this.els.totalWorkouts.textContent = history.length;
        this.els.totalCycles.textContent = history.reduce((sum, w) => sum + (w.cycles || 0), 0);
        if (history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = history.map(w => {
          const date = new Date(w.date);
          const duration = Math.floor((w.totalTime) / 60);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} • ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${w.cycles} cycles × ${w.secondsPerCycle}s</div>
            <div class="history-details">${duration}min workout</div>
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          this.saveHistory([]);
          this.loadHistory();
        }
      },
      exportHistory() {
        const history = this.getHistory();
        if (history.length === 0) return;
        const head = ['date', 'secondsPerCycle', 'completedCycles', 'totalTimeSeconds', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          w.secondsPerCycle,
          w.cycles,
          w.totalTime,
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'emom_history.csv');
      },
      saveWorkout(data, notes = '') {
        const workout = { id: Date.now(), date: new Date().toISOString(), ...data, notes };
        let history = this.getHistory();
        history.unshift(workout);
        if (history.length > 50) history.pop();
        this.saveHistory(history);
        this.currentWorkout = workout;
      },
      updateWorkoutNotes(id, notes) {
        let history = this.getHistory();
        const workout = history.find(w => w.id === id);
        if (workout) {
          workout.notes = notes;
          this.saveHistory(history);
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          let history = this.getHistory();
          history = history.filter(w => w.id !== id);
          this.saveHistory(history);
          this.loadHistory();
      },
      
      // Modals
      closeAllModals() {
        document.querySelectorAll('#emom_presetModal, #emom_notesModal, #emom_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) this.showCompletionModal();
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));
        if (workoutId) {
          this.updateWorkoutNotes(workoutId, notes);
        } else if (this.currentWorkout) {
          this.updateWorkoutNotes(this.currentWorkout.id, notes);
          this.currentWorkout.notes = notes;
        }
        this.closeAllModals();
        if (this.currentWorkout && !workoutId) {
          this.showCompletionModal();
        }
      },
      openNotesModal(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          this.els.workoutNotes.value = workout.notes || '';
          this.els.notesModal.setAttribute('data-workout-id', id);
          this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        const duration = Math.floor(this.currentWorkout.totalTime / 60);
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${this.currentWorkout.cycles}</strong> cycles completed</div>
          <div class="completion-stat"><strong>${this.currentWorkout.secondsPerCycle}s</strong> per cycle</div>
          <div class="completion-stat"><strong>${duration} minutes</strong> total workout</div>`;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        this.els.workoutNotes.value = this.currentWorkout?.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', this.currentWorkout.id);
        this.els.notesModal.classList.add('active');
      },
      shareResult() {
        if (!this.currentWorkout) return;
        this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          const date = new Date(workout.date).toLocaleDateString();
          const duration = Math.floor(workout.totalTime / 60);
          const notesText = workout.notes ? `\n\nNotes: ${workout.notes}` : '';
          const text = t('share_text_emom', {
            cycles: workout.cycles,
            seconds: workout.secondsPerCycle,
            duration: duration,
            date: date,
            notes: notesText
          });
          if (navigator.share) {
            navigator.share({ title: 'EMOM Workout Complete!', text });
          } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
          }
      },
      
      loadSettingsFromLocalStorage() {
        this.applyCycleSeconds(localStorage.getItem('emom_cycleSeconds') || 60);
        this.els.targetInput.value = localStorage.getItem('emom_targetCycles') || '';
        this.handleTargetInputChange();
      },
    };

    // === TABATA APP LOGIC ===
    const TabataApp = {
      workTime: 20, restTime: 10, totalCycles: 8,
      mode: 'idle', // 'prep', 'work', 'rest', 'paused', 'completed'
      currentCycle: 0, timeRemaining: 20,
      running: false, paused: false, prepInterval: null,
      animationFrameId: null, startTime: 0, pauseTime: 0, pausedDuration: 0,
      lastAnnouncedSecond: null, editingPresetIndex: -1,
      currentWorkout: null,
      history: [], customPresets: [], initialized: false,
      workoutViewActive: false,
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.history = JSON.parse(localStorage.getItem('tabata_history') || '[]');
        this.customPresets = JSON.parse(localStorage.getItem('tabata_presets') || '[]');
        this.setupEventListeners();
        this.updateUI();
        this.renderCustomPresets();
        this.loadHistory();
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'timer', 'prep', 'status', 'progress', 'workInput', 'restInput', 'cyclesInput', 'startBtn', 'pauseBtn', 'resumeBtn', 'resetBtn', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsContainer', 'addPresetBtn', 'quick', 'presetsList', 'historyList', 'totalWorkouts', 'totalCycles', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetWork', 'presetRest', 'presetCycles', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`tabata_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#tabata_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#tabata_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#tabata_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#tabata_presetModal [data-modal-close], #tabata_notesModal [data-modal-close], #tabata_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#tabata_presetModal [data-modal-cancel]');
         // Shared workout view elements
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutProgress = document.getElementById('workoutProgress');
        this.els.workoutStatus = document.getElementById('workoutStatus');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyQuickPreset(btn)));
        ['workInput', 'restInput', 'cyclesInput'].forEach(key => {
            this.els[key].addEventListener('input', () => this.updateValues());
            this.els[key].addEventListener('blur', () => this.validateTabataInputs());
        });
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && TabataApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && TabataApp.running) this.handleWorkoutPause() });
        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;

            const { action, id, index } = target.dataset;

            switch(action) {
                case 'apply-preset':
                    this.applyPreset(parseInt(index, 10));
                    break;
                case 'delete-preset':
                    e.stopPropagation();
                    if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10));
                    break;
                case 'edit-preset':
                    this.openPresetModal(parseInt(index, 10));
                    break;
                case 'clear-history':
                    this.clearHistory();
                    break;
                case 'export-history':
                    this.exportHistory();
                    break;
                case 'edit-history':
                    this.openNotesModal(parseInt(id, 10));
                    break;
                case 'share-history':
                    this.shareWorkout(parseInt(id, 10));
                    break;
                case 'delete-history':
                    if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10));
                    break;
            }
        });
      },

      validateTabataInputs() {
        let workVal = parseInt(this.els.workInput.value, 10);
        this.els.workInput.value = (!isNaN(workVal) && workVal > 0) ? workVal : 20;

        let restVal = parseInt(this.els.restInput.value, 10);
        this.els.restInput.value = (!isNaN(restVal) && restVal >= 0) ? restVal : 10;

        let cyclesVal = parseInt(this.els.cyclesInput.value, 10);
        this.els.cyclesInput.value = (!isNaN(cyclesVal) && cyclesVal > 0) ? cyclesVal : 8;
        
        this.updateValues();
      },
      
      updateLanguage() {
        this.updateUI();
        this.renderCustomPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `tabata_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderCustomPresets();
      },
      
      applyQuickPreset(btn) {
        const presetStr = btn.dataset.preset;
        const [work, rest, cycles] = presetStr.split('-').map(Number);
        this.els.workInput.value = work;
        this.els.restInput.value = rest;
        this.els.cyclesInput.value = cycles;
        this.updateValues();
        document.querySelectorAll('#tabata_app .preset-btn, #tabata_app .quick-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      },
      
      updateValues() {
        this.workTime = parseInt(this.els.workInput.value) || 20;
        this.restTime = parseInt(this.els.restInput.value) || 10;
        this.totalCycles = parseInt(this.els.cyclesInput.value) || 8;
        if (!this.running) {
          this.timeRemaining = this.workTime;
          this.updateUI();
        }
      },
      
      updateUI() {
        this.els.timer.textContent = this.timeRemaining;
        this.els.progress.textContent = `${t('progress').replace(':', '')} ${this.currentCycle}/${this.totalCycles}`;
        
        const statusMap = {
          idle: { key: 'ready', class: 'idle' },
          prep: { key: 'preparing', class: 'ready' },
          work: { key: 'status_work', class: 'running' },
          rest: { key: 'status_rest', class: 'paused' },
          paused: { key: 'paused', class: 'paused' },
          completed: { key: 'workout_complete_status', class: 'completed' },
        };
        const newStatus = statusMap[this.mode] || statusMap.idle;
        this.setStatus(newStatus.key, newStatus.class);

        if (this.workoutViewActive) this.updateWorkoutView();
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },
      
      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        this.updateValues();
        this.currentCycle = 0;
        this.timeRemaining = this.workTime;
        this.running = true;
        this.paused = false;
        this.els.startBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
        this.els.resumeBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
        this.updateUI();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.startTiming();
          this.openWorkoutView();
        });
      },
      
      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.animationFrameId = null; this.prepInterval = null;
        this.mode = 'paused';
        this.updateUI();
        releaseWakeLock();
        this.els.resumeBtn.disabled = false;
        this.els.startBtn.disabled = true;
        this.els.pauseBtn.disabled = true;
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.updateUI(); // mode will be updated in tick
        this.els.resumeBtn.disabled = true;
        this.els.pauseBtn.disabled = false;
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.animationFrameId = null; this.prepInterval = null;
        releaseWakeLock();
        this.mode = 'idle';
        this.currentCycle = 0;
        this.updateValues();
        this.els.prep.style.display = 'none';
        this.els.timer.style.display = 'block';
        this.updateUI();
        this.els.startBtn.disabled = false;
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.mode = 'prep';
        this.updateUI();
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval);
            this.prepInterval = null;
            ring();
            setTimeout(() => {
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },

      startTiming() {
        this.startTime = performance.now();
        this.pausedDuration = 0;
        this.lastAnnouncedSecond = null;
        if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      tick() {
        if (!this.running || this.paused) return;
        
        const elapsedMs = performance.now() - this.startTime - this.pausedDuration;
        const totalCycleDurationMs = (this.workTime + this.restTime) * 1000;
        
        const newCycle = Math.floor(elapsedMs / totalCycleDurationMs);
        if(this.currentCycle !== newCycle) {
            this.currentCycle = newCycle;
        }

        if(this.currentCycle >= this.totalCycles) {
            this.completeWorkout();
            return;
        }

        const elapsedInCurrentCycleMs = elapsedMs % totalCycleDurationMs;
        const workTimeMs = this.workTime * 1000;
        let newMode, newRemaining;
        
        if (elapsedInCurrentCycleMs < workTimeMs) {
            newMode = 'work';
            newRemaining = this.workTime - Math.floor(elapsedInCurrentCycleMs / 1000);
        } else {
            newMode = 'rest';
            const elapsedInRest = elapsedInCurrentCycleMs - workTimeMs;
            newRemaining = this.restTime - Math.floor(elapsedInRest / 1000);
        }
        
        if (this.mode !== newMode) {
            this.mode = newMode;
            ring();
        }
        if(this.timeRemaining !== newRemaining) {
            this.timeRemaining = newRemaining;
            this.updateUI();
        }

        if (this.timeRemaining <= 5 && this.timeRemaining > 0 && this.lastAnnouncedSecond !== this.timeRemaining) {
          beepShort();
          this.lastAnnouncedSecond = this.timeRemaining;
        } else if (this.timeRemaining > 5) {
          this.lastAnnouncedSecond = null;
        }

        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      completeWorkout() {
        this.closeWorkoutView();
        this.running = false; this.paused = false;
        if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        this.mode = 'completed';
        this.updateUI();
        victoryBells();
        releaseWakeLock();
        
        this.currentWorkout = {
          id: Date.now(), date: new Date().toISOString(), cycles: this.totalCycles, work: this.workTime,
          rest: this.restTime, totalTime: this.totalCycles * (this.workTime + this.restTime)
        };
        
        this.els.startBtn.disabled = false;
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        
        setTimeout(() => {
          this.els.workoutNotes.value = '';
          this.els.notesModal.setAttribute('data-workout-id', '');
          this.els.notesModal.classList.add('active');
        }, 1000);
      },
      
      // Workout View
      openWorkoutView() {
        this.workoutViewActive = true;
        // Configure for Tabata
        this.els.workoutStatus.style.display = 'block';
        document.getElementById('workoutLapBtn').style.display = 'none';
        document.getElementById('workoutLapsList').parentElement.style.display = 'none';
        this.els.workoutProgress.style.display = 'block';
        this.els.workoutTimer.classList.remove('fortime');
        this.els.workoutTimer.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden';
        this.updateWorkoutView();
      },
      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = '';
      },
      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        
        this.els.workoutTimer.textContent = this.timeRemaining;
        this.els.workoutProgress.textContent = `${t('progress').replace(':', '')} ${this.currentCycle}/${this.totalCycles}`;
        
        const statusMap = {
            work: { key: 'status_work', color: 'var(--accent)' },
            rest: { key: 'status_rest', color: 'var(--warn)' },
        };
        
        const currentStatus = statusMap[this.mode];
        if (currentStatus) {
            this.els.workoutStatus.textContent = t(currentStatus.key);
            this.els.workoutStatus.style.color = currentStatus.color;
            this.els.workoutStatus.style.display = 'block';
        } else {
            this.els.workoutStatus.style.display = 'none';
        }

        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        this.els.workoutPauseBtn.disabled = !this.running;
      },
      handleWorkoutPause() {
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },
      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },
      
      // Presets
      renderCustomPresets() {
        // Clear only the user presets, not the "add new" button
        this.els.presetsContainer.innerHTML = '';
        this.customPresets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">×</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          if (!this.customPresets[index]) return;
          const preset = this.customPresets[index];
          this.els.workInput.value = preset.work;
          this.els.restInput.value = preset.rest;
          this.els.cyclesInput.value = preset.cycles;
          this.updateValues();
          document.querySelectorAll('#tabata_app .preset-btn, #tabata_app .quick-btn').forEach(b => b.classList.remove('active'));
          // Find the button and activate it
          const btnToActivate = this.els.presetsContainer.querySelector(`[data-index="${index}"]`);
          if (btnToActivate) btnToActivate.classList.add('active');
      },
      loadPresetsList() {
        if (this.customPresets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets_tabata')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = this.customPresets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${p.work}s ${t('work_seconds_short')} • ${p.rest}s ${t('rest_seconds_short')} • ${p.cycles} ${t('cycles')}</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        if (index > -1 && this.customPresets[index]) {
          const p = this.customPresets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title_tabata');
          this.els.presetName.value = p.name;
          this.els.presetWork.value = p.work;
          this.els.presetRest.value = p.rest;
          this.els.presetCycles.value = p.cycles;
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title_tabata');
          this.els.presetName.value = '';
          this.els.presetWork.value = this.workTime;
          this.els.presetRest.value = this.restTime;
          this.els.presetCycles.value = this.totalCycles;
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const work = parseInt(this.els.presetWork.value);
        const rest = parseInt(this.els.presetRest.value);
        const cycles = parseInt(this.els.presetCycles.value);
        if (!name || !work || !rest || !cycles) { alert(t('alert_fill_fields')); return; }
        const preset = { name, work, rest, cycles };
        if (this.editingPresetIndex >= 0) {
          this.customPresets[this.editingPresetIndex] = preset;
        } else {
          this.customPresets.push(preset);
        }
        localStorage.setItem('tabata_presets', JSON.stringify(this.customPresets));
        this.renderCustomPresets();
        this.closeAllModals();
      },
      deletePreset(index) {
          this.customPresets.splice(index, 1);
          localStorage.setItem('tabata_presets', JSON.stringify(this.customPresets));
          this.renderCustomPresets();
      },

      // History
      loadHistory() {
        this.els.totalWorkouts.textContent = this.history.length;
        this.els.totalCycles.textContent = this.history.reduce((sum, w) => sum + (w.cycles || 0), 0);
        if (this.history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history_tabata')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = this.history.map(w => {
          const date = new Date(w.date);
          const duration = Math.floor(w.totalTime / 60);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} • ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${w.cycles} ${t('cycles')} • ${w.work}s/${w.rest}s</div>
            <div class="history-details">${duration}min workout</div>
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      exportHistory() {
        const history = this.history;
        if (history.length === 0) return;
        const head = ['date', 'workSeconds', 'restSeconds', 'completedCycles', 'totalTimeSeconds', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          w.work,
          w.rest,
          w.cycles,
          w.totalTime,
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'tabata_history.csv');
      },
      saveWorkout(notes = '') {
        if (!this.currentWorkout) return;
        this.currentWorkout.notes = notes;
        this.history.unshift(this.currentWorkout);
        if (this.history.length > 50) this.history.pop();
        localStorage.setItem('tabata_history', JSON.stringify(this.history));
        this.loadHistory();
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          localStorage.removeItem('tabata_history');
          this.history = [];
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          this.history = this.history.filter(w => w.id !== id);
          localStorage.setItem('tabata_history', JSON.stringify(this.history));
          this.loadHistory();
      },

      // Modals
      closeAllModals() {
        document.querySelectorAll('#tabata_presetModal, #tabata_notesModal, #tabata_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) {
          this.saveWorkout('');
          this.showCompletionModal();
        }
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));

        if (workoutId) {
          const workout = this.history.find(w => w.id === workoutId);
          if (workout) {
            workout.notes = notes;
            localStorage.setItem('tabata_history', JSON.stringify(this.history));
          }
          this.loadHistory();
        } else if (this.currentWorkout) {
          this.saveWorkout(notes);
          this.showCompletionModal();
        }
        this.closeAllModals();
      },
      openNotesModal(id) {
        const workout = this.history.find(w => w.id === id);
        if (!workout) return;
        this.els.workoutNotes.value = workout.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', id);
        this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        const duration = Math.floor(this.currentWorkout.totalTime / 60);
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${this.currentWorkout.cycles}</strong> ${t('cycles')} ${t('completed_cycles')}</div>
          <div class="completion-stat"><strong>${this.currentWorkout.work}s</strong> ${t('work_seconds_short')} / <strong>${this.currentWorkout.rest}s</strong> ${t('rest_seconds_short')}</div>
          <div class="completion-stat"><strong>${duration}</strong> ${t('minutes_total')}</div>`;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        if (this.currentWorkout) {
          this.openNotesModal(this.currentWorkout.id);
        }
      },
      shareResult() {
        if(this.currentWorkout) this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
        const workout = this.history.find(w => w.id === id);
        if (!workout) return;
        const date = new Date(workout.date).toLocaleDateString();
        const duration = Math.floor(workout.totalTime / 60);
        const notesText = workout.notes ? `\n\n${t('workout_notes')}: ${workout.notes}` : '';
        const text = t('share_text_tabata', {
          cycles: workout.cycles,
          work: workout.work,
          rest: workout.rest,
          duration: duration,
          date: date,
          notes: notesText
        });

        if (navigator.share) {
          navigator.share({ title: t('share_title_tabata'), text });
        } else if (navigator.clipboard) {
          navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
        }
      }
    };

    // === FOR TIME APP LOGIC ===
    const ForTimeApp = {
      // State
      timeCap: null, prepInterval: null, running: false, paused: false, inPrep: false,
      startTime: 0, pauseTime: 0, pausedDuration: 0, elapsedTime: 0,
      laps: [], animationFrameId: null,
      currentWorkout: null, editingPresetIndex: -1, initialized: false,
      workoutViewActive: false,
      lastAnnouncedCapSecond: null,
      midpointAnnounced: false,
      
      // DOM Elements
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.renderPresets();
        this.loadHistory();
        this.updateUI();
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'timeCapInput', 'status', 'prep', 'timer', 'startBtn', 'stopBtn', 'pauseBtn', 'resumeBtn', 'lapBtn', 'resetBtn', 'lapsList', 'presetsContainer', 'addPresetBtn', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsList', 'historyList', 'totalWorkouts', 'totalLaps', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetTimeCap', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`fortime_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#fortime_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#fortime_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#fortime_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#fortime_presetModal [data-modal-close], #fortime_notesModal [data-modal-close], #fortime_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#fortime_presetModal [data-modal-cancel]');
        // Elementos de la vista de entrenamiento
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutLapBtn = document.getElementById('workoutLapBtn');
        this.els.workoutLapsList = document.getElementById('workoutLapsList');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyTimeCap(parseInt(btn.dataset.quick, 10))));
        this.els.timeCapInput.addEventListener('input', () => this.handleTimeCapChange());
        this.els.timeCapInput.addEventListener('blur', () => this.validateForTimeInputs());
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.stopBtn.addEventListener('click', () => this.stop());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.lapBtn.addEventListener('click', () => this.lap());
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;
            const { action, id, index } = target.dataset;
            switch(action) {
                case 'apply-preset': this.applyPreset(parseInt(index, 10)); break;
                case 'delete-preset': e.stopPropagation(); if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10)); break;
                case 'edit-preset': this.openPresetModal(parseInt(index, 10)); break;
                case 'clear-history': this.clearHistory(); break;
                case 'export-history': this.exportHistory(); break;
                case 'edit-history': this.openNotesModal(parseInt(id, 10)); break;
                case 'share-history': this.shareWorkout(parseInt(id, 10)); break;
                case 'delete-history': if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10)); break;
            }
        });
         // Event listeners para la vista de entrenamiento
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && ForTimeApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && ForTimeApp.running) this.handleWorkoutPause() });
        this.els.workoutLapBtn.addEventListener('click', () => { if(this.workoutViewActive && ForTimeApp.running) this.lap()});
      },
      
      validateForTimeInputs() {
        let val = parseInt(this.els.timeCapInput.value, 10);
        if (isNaN(val) || val <= 0) {
            this.els.timeCapInput.value = '';
        } else {
            this.els.timeCapInput.value = val;
        }
        this.handleTimeCapChange();
      },

      openWorkoutView() {
        this.workoutViewActive = true;
        // Configure for ForTime
        document.getElementById('workoutStatus').style.display = 'none';
        document.getElementById('workoutProgress').style.display = 'none';
        this.els.workoutLapBtn.style.display = 'inline-block';
        this.els.workoutLapsList.parentElement.style.display = 'block';
        this.els.workoutTimer.classList.add('fortime');
        this.els.workoutTimer.style.fontFamily = 'monospace';
        
        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevenir scroll del body
        this.els.workoutLapBtn.textContent = t('lap');
        this.updateWorkoutView();
      },

      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = ''; // Restaurar scroll
      },

      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        
        this.els.workoutTimer.textContent = this.formatTime(this.elapsedTime);
        
        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        
        this.els.workoutLapsList.innerHTML = this.laps.map((lapTime, i) => `
          <li class="lap-item">
            <span>${t('lap')} ${i + 1}</span>
            <span>${this.formatTime(lapTime)}</span>
          </li>
        `).reverse().join('');
        
        this.els.workoutPauseBtn.disabled = !this.running;
        this.els.workoutLapBtn.disabled = !this.running || this.paused;
      },

      handleWorkoutPause() {
        if (!this.running) return;
        
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },

      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },

      updateLanguage() {
        this.updateUI();
        this.renderPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `fortime_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderPresets();
      },
      
      applyTimeCap(minutes) {
        if (isNaN(minutes)) return;
        this.els.timeCapInput.value = minutes;
        this.handleTimeCapChange();
      },

      handleTimeCapChange() {
        const val = this.els.timeCapInput.value.trim();
        const minutes = val ? parseInt(val, 10) : null;
        this.timeCap = minutes ? minutes * 60 * 1000 : null; // convert minutes to ms
        if(this.els.quickBtns) { // check if it exists
             this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === minutes));
        }
      },

      formatTime(ms) {
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        const centiseconds = Math.floor((ms % 1000) / 10);
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
      },

      updateUI() {
        this.els.timer.textContent = this.formatTime(this.elapsedTime);
        this.renderLaps();
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },

      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        this.resetAll();
        this.handleTimeCapChange();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.running = true;
          this.startTime = performance.now();
          this.pausedDuration = 0;
          this.animationFrameId = requestAnimationFrame(() => this.tick());
          this.setStatus('training', 'running');
          this.els.startBtn.style.display = 'none';
          this.els.stopBtn.style.display = 'inline-block';
          this.els.pauseBtn.disabled = false;
          this.els.lapBtn.disabled = false;
          this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
          this.openWorkoutView();
        });
      },

      stop(isTimeCap = false) {
        if (!this.running) return;
        this.closeWorkoutView();
        this.running = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if(!isTimeCap) this.elapsedTime = performance.now() - this.startTime - this.pausedDuration;
        this.updateUI();
        this.completeWorkout();
      },

      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) { clearInterval(this.prepInterval); this.prepInterval = null; }
        this.setStatus('paused', 'paused');
        releaseWakeLock();
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = false;
        this.els.lapBtn.disabled = true;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.setStatus('training', 'running');
        this.els.pauseBtn.disabled = false;
        this.els.resumeBtn.disabled = true;
        this.els.lapBtn.disabled = false;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },

      lap() {
        if (!this.running || this.paused) return;
        this.laps.push(this.elapsedTime);
        this.renderLaps();
        beepShort();
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false; this.inPrep = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        releaseWakeLock();
        this.elapsedTime = 0; this.laps = []; this.pausedDuration = 0;
        this.lastAnnouncedCapSecond = null;
        this.midpointAnnounced = false;
        this.els.prep.style.display = 'none'; 
        this.els.timer.style.display = 'block';
        this.setStatus('ready', 'idle');
        this.els.startBtn.style.display = 'inline-block';
        this.els.stopBtn.style.display = 'none';
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.lapBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
        this.updateUI();
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.inPrep = true;
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        this.setStatus('preparing', 'ready');
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval); this.prepInterval = null;
            ring();
            setTimeout(() => {
              this.inPrep = false;
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },
      
      tick() {
        if (!this.running || this.paused) return;
        this.elapsedTime = performance.now() - this.startTime - this.pausedDuration;

        if (this.timeCap) {
          if (this.elapsedTime >= this.timeCap) {
            this.elapsedTime = this.timeCap;
            this.stop(true);
            return;
          }

          // Midpoint sound alert
          if (!this.midpointAnnounced && this.elapsedTime >= (this.timeCap / 2)) {
            ring();
            this.midpointAnnounced = true;
          }

          // Final countdown before time cap
          const timeRemainingMs = this.timeCap - this.elapsedTime;
          const secondsRemaining = Math.ceil(timeRemainingMs / 1000);

          if (secondsRemaining <= 5 && secondsRemaining > 0) {
            if (this.lastAnnouncedCapSecond !== secondsRemaining) {
              beepShort();
              this.lastAnnouncedCapSecond = secondsRemaining;
            }
          }
        }

        this.updateUI();
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      renderLaps() {
        this.els.lapsList.innerHTML = this.laps.map((lapTime, i) => `
          <li class="lap-item">
            <span>${t('lap')} ${i + 1}</span>
            <span>${this.formatTime(lapTime)}</span>
          </li>
        `).reverse().join('');
      },

      completeWorkout() {
        releaseWakeLock();
        this.setStatus('workout_complete_status', 'completed');
        victoryBells();
        this.saveWorkout({ finalTime: this.elapsedTime, timeCap: this.timeCap, laps: this.laps });
        setTimeout(() => this.els.notesModal.classList.add('active'), 1000);
      },
      
      // Presets
      getPresets() { return JSON.parse(localStorage.getItem('fortime_presets') || '[]'); },
      savePresets(presets) { localStorage.setItem('fortime_presets', JSON.stringify(presets)); },
      renderPresets() {
        const presets = this.getPresets();
        this.els.presetsContainer.innerHTML = '';
        presets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">×</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          const presets = this.getPresets();
          if (!presets[index]) return;
          const preset = presets[index];
          this.els.timeCapInput.value = preset.timeCap || '';
          this.handleTimeCapChange();
      },
      deletePreset(index) {
          let presets = this.getPresets();
          presets.splice(index, 1);
          this.savePresets(presets);
          this.renderPresets();
      },
      loadPresetsList() {
        const presets = this.getPresets();
        if (presets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets_fortime')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = presets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${p.timeCap ? `${t('time_cap')} ${p.timeCap} min` : t('leave_empty_unlimited')}</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        const presets = this.getPresets();
        if (index > -1 && presets[index]) {
          const p = presets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title_fortime');
          this.els.presetName.value = p.name;
          this.els.presetTimeCap.value = p.timeCap || '';
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title_fortime');
          this.els.presetName.value = '';
          this.els.presetTimeCap.value = this.timeCap ? this.timeCap / 60000 : '';
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const timeCap = this.els.presetTimeCap.value ? parseInt(this.els.presetTimeCap.value) : null;
        if (!name) { alert(t('alert_fill_fields')); return; }
        
        const presets = this.getPresets();
        const newPreset = { name, timeCap };

        if (this.editingPresetIndex > -1) {
          presets[this.editingPresetIndex] = newPreset;
        } else {
          presets.push(newPreset);
        }
        this.savePresets(presets);
        this.renderPresets();
        this.closeAllModals();
      },
      
      // History
      getHistory() { return JSON.parse(localStorage.getItem('fortime_history') || '[]'); },
      saveHistory(history) { localStorage.setItem('fortime_history', JSON.stringify(history)); },
      loadHistory() {
        const history = this.getHistory();
        this.els.totalWorkouts.textContent = history.length;
        this.els.totalLaps.textContent = history.reduce((sum, w) => sum + (w.laps?.length || 0), 0);
        if (history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history_fortime')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = history.map(w => {
          const date = new Date(w.date);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} • ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${t('final_time')}: ${this.formatTime(w.finalTime)}</div>
            <div class="history-details">${w.laps.length} Laps ${w.timeCap ? `• Time Cap: ${w.timeCap / 60000}min` : ''}</div>
            ${w.laps && w.laps.length > 0 ? `
              <div class="history-laps">
                <ul>
                  ${w.laps.map((lapTime, i) => `<li>${t('lap')} ${i + 1}: ${this.formatTime(lapTime)}</li>`).join('')}
                </ul>
              </div>
            ` : ''}
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      exportHistory() {
        const history = this.getHistory();
        if (history.length === 0) return;
        const head = ['date', 'finalTime', 'timeCapMinutes', 'lapsCount', 'laps', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          this.formatTime(w.finalTime),
          w.timeCap ? w.timeCap / 60000 : '',
          w.laps.length,
          w.laps.map(l => this.formatTime(l)).join('; '),
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'fortime_history.csv');
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          this.saveHistory([]);
          this.loadHistory();
        }
      },
      saveWorkout(data, notes = '') {
        const workout = { id: Date.now(), date: new Date().toISOString(), ...data, notes };
        let history = this.getHistory();
        history.unshift(workout);
        if (history.length > 50) history.pop();
        this.saveHistory(history);
        this.currentWorkout = workout;
        this.loadHistory();
      },
      updateWorkoutNotes(id, notes) {
        let history = this.getHistory();
        const workout = history.find(w => w.id === id);
        if (workout) {
          workout.notes = notes;
          this.saveHistory(history);
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          let history = this.getHistory();
          history = history.filter(w => w.id !== id);
          this.saveHistory(history);
          this.loadHistory();
      },
      
      // Modals
      closeAllModals() {
        document.querySelectorAll('#fortime_presetModal, #fortime_notesModal, #fortime_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) this.showCompletionModal();
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));
        if (workoutId) {
          this.updateWorkoutNotes(workoutId, notes);
        } else if (this.currentWorkout) {
          this.updateWorkoutNotes(this.currentWorkout.id, notes);
          this.currentWorkout.notes = notes;
        }
        this.closeAllModals();
        if (this.currentWorkout && !workoutId) {
          this.showCompletionModal();
        }
      },
      openNotesModal(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          this.els.workoutNotes.value = workout.notes || '';
          this.els.notesModal.setAttribute('data-workout-id', id);
          this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${t('final_time')}:</strong> ${this.formatTime(this.currentWorkout.finalTime)}</div>
          <div class="completion-stat"><strong>${this.currentWorkout.laps.length}</strong> Laps</div>
          ${this.currentWorkout.timeCap ? `<div class="completion-stat"><strong>Time Cap:</strong> ${this.currentWorkout.timeCap/60000} min</div>` : ''}
          `;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        this.els.workoutNotes.value = this.currentWorkout?.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', this.currentWorkout.id);
        this.els.notesModal.classList.add('active');
      },
      shareResult() {
        if (!this.currentWorkout) return;
        this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          const date = new Date(workout.date).toLocaleDateString();
          const timeCapText = workout.timeCap ? `\nTime Cap: ${workout.timeCap/60000}min` : '';
          const notesText = workout.notes ? `\n\nNotes: ${workout.notes}` : '';
          const text = t('share_text_fortime', {
            time: this.formatTime(workout.finalTime),
            lapsCount: workout.laps.length,
            date: date,
            timeCapText: timeCapText,
            notes: notesText
          });
          if (navigator.share) {
            navigator.share({ title: t('share_title_fortime'), text });
          } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
          }
      },
    };

       // === AMRAP APP LOGIC ===
    const AmrapApp = {
      // State
      duration: 600000, // 10 minutes in ms
      prepInterval: null, running: false, paused: false, inPrep: false,
      startTime: 0, pauseTime: 0, pausedDuration: 0, remainingTime: 600000,
      rounds: 0, animationFrameId: null,
      currentWorkout: null, editingPresetIndex: -1, initialized: false,
      workoutViewActive: false,
      lastAnnouncedSecond: null,
      midpointAnnounced: false,
      
      // DOM Elements
      els: {},

      init() {
        if(this.initialized) return;
        this.cacheDOMElements();
        this.setupEventListeners();
        this.renderPresets();
        this.loadHistory();
        this.handleDurationChange(); // Initialize with default value
        this.initialized = true;
      },
      
      cacheDOMElements() {
        const ids = ['app', 'durationInput', 'status', 'prep', 'timer', 'startBtn', 'pauseBtn', 'resumeBtn', 'roundBtn', 'resetBtn', 'rounds', 'presetsContainer', 'addPresetBtn', 'tabs-nav', 'timer-tab', 'presets-tab', 'history-tab', 'presetsList', 'historyList', 'totalWorkouts', 'totalRounds', 'clearHistoryBtn', 'exportHistoryBtn', 'presetModal', 'presetModalTitle', 'presetName', 'presetDuration', 'savePreset', 'notesModal', 'workoutNotes', 'skipNotes', 'saveNotes', 'completionModal', 'completionStats', 'shareResult', 'addNotesBtn', 'toggleWorkoutViewBtn'];
        ids.forEach(id => this.els[id] = document.getElementById(`amrap_${id}`));
        this.els.tabBtns = Array.from(document.querySelectorAll('#amrap_tabs-nav .tab-btn'));
        this.els.tabContents = Array.from(document.querySelectorAll('#amrap_app .tab-content'));
        this.els.quickBtns = Array.from(document.querySelectorAll('#amrap_quick button'));
        this.els.modalCloseBtns = document.querySelectorAll('#amrap_presetModal [data-modal-close], #amrap_notesModal [data-modal-close], #amrap_completionModal [data-modal-close]');
        this.els.modalCancelBtns = document.querySelectorAll('#amrap_presetModal [data-modal-cancel]');
        // Shared workout view elements
        this.els.workoutView = document.getElementById('workoutView');
        this.els.workoutClose = document.getElementById('workoutClose');
        this.els.workoutTimer = document.getElementById('workoutTimer');
        this.els.workoutPrep = document.getElementById('workoutPrep');
        this.els.workoutPauseBtn = document.getElementById('workoutPauseBtn');
        this.els.workoutLapBtn = document.getElementById('workoutLapBtn'); // Reused for rounds
        this.els.workoutProgress = document.getElementById('workoutProgress');
      },

      setupEventListeners() {
        this.els.tabBtns.forEach(btn => btn.addEventListener('click', () => this.handleTabClick(btn)));
        this.els.quickBtns.forEach(btn => btn.addEventListener('click', () => this.applyDuration(parseInt(btn.dataset.quick, 10))));
        this.els.durationInput.addEventListener('input', () => this.handleDurationChange());
        this.els.durationInput.addEventListener('blur', () => this.validateAmrapInputs());
        this.els.startBtn.addEventListener('click', () => this.start());
        this.els.pauseBtn.addEventListener('click', () => this.pause());
        this.els.resumeBtn.addEventListener('click', () => this.resumeWithPrep(this.els.prep, this.els.timer));
        this.els.roundBtn.addEventListener('click', () => this.addRound());
        this.els.resetBtn.addEventListener('click', () => this.resetAll());
        this.els.addPresetBtn.addEventListener('click', () => this.openPresetModal());
        this.els.savePreset.addEventListener('click', () => this.savePreset());
        this.els.skipNotes.addEventListener('click', () => this.handleSkipNotes());
        this.els.saveNotes.addEventListener('click', () => this.handleSaveNotes());
        this.els.shareResult.addEventListener('click', () => this.shareResult());
        this.els.addNotesBtn.addEventListener('click', () => this.openNotesFromCompletion());
        this.els.toggleWorkoutViewBtn.addEventListener('click', () => this.openWorkoutView());
        this.els.modalCloseBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        this.els.modalCancelBtns.forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
        
        this.els.app.addEventListener('click', (e) => {
            const target = e.target.closest('[data-action]');
            if (!target) return;
            const { action, id, index } = target.dataset;
            switch(action) {
                case 'apply-preset': this.applyPreset(parseInt(index, 10)); break;
                case 'delete-preset': e.stopPropagation(); if (confirm(t('confirm_delete_preset'))) this.deletePreset(parseInt(index, 10)); break;
                case 'edit-preset': this.openPresetModal(parseInt(index, 10)); break;
                case 'clear-history': this.clearHistory(); break;
                case 'export-history': this.exportHistory(); break;
                case 'edit-history': this.openNotesModal(parseInt(id, 10)); break;
                case 'share-history': this.shareWorkout(parseInt(id, 10)); break;
                case 'delete-history': if (confirm(t('confirm_delete_history'))) this.deleteWorkout(parseInt(id, 10)); break;
            }
        });
         // Event listeners para la vista de entrenamiento
        this.els.workoutClose.addEventListener('click', () => { if (this.workoutViewActive && AmrapApp.running) this.closeWorkoutView() });
        this.els.workoutPauseBtn.addEventListener('click', () => { if (this.workoutViewActive && AmrapApp.running) this.handleWorkoutPause() });
        this.els.workoutLapBtn.addEventListener('click', () => { if(this.workoutViewActive && AmrapApp.running) this.addRound()});
      },

      validateAmrapInputs() {
        let val = parseInt(this.els.durationInput.value, 10);
        if (isNaN(val) || val <= 0) {
            this.els.durationInput.value = 10;
        } else {
            this.els.durationInput.value = val;
        }
        this.handleDurationChange();
      },

      updateLanguage() {
        this.updateUI();
        this.renderPresets();
        this.loadHistory();
      },

      handleTabClick(btn) {
        const targetTab = btn.dataset.tab;
        this.els.tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.els.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === `amrap_${targetTab}-tab`);
        });
        if (targetTab === 'history') this.loadHistory();
        else if (targetTab === 'presets') this.renderPresets();
      },
      
      applyDuration(minutes) {
        if (isNaN(minutes)) return;
        this.els.durationInput.value = minutes;
        this.handleDurationChange();
      },

      handleDurationChange() {
        const val = this.els.durationInput.value.trim();
        const minutes = val ? parseInt(val, 10) : 10; // Default to 10 if empty
        this.duration = minutes * 60 * 1000;
        if(this.els.quickBtns) {
             this.els.quickBtns.forEach(b => b.classList.toggle('active', parseInt(b.dataset.quick) === minutes));
        }
        if (!this.running) {
          this.remainingTime = this.duration;
          this.updateUI();
        }
      },

      formatTime(ms) {
        const totalSeconds = Math.ceil(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      },

      updateUI() {
        this.els.timer.textContent = this.formatTime(this.remainingTime);
        this.els.rounds.textContent = `${t('completed_rounds')} ${this.rounds}`;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      setStatus(statusKey, className) {
        this.els.status.textContent = t(statusKey);
        this.els.status.className = `status ${className}`;
      },

      async start() {
        await ensureAudioContext();
        await requestWakeLock();
        this.resetAll();
        this.handleDurationChange();
        this.startPreparation(this.els.prep, this.els.timer, () => {
          this.running = true;
          this.startTime = performance.now();
          this.pausedDuration = 0;
          this.animationFrameId = requestAnimationFrame(() => this.tick());
          this.setStatus('training', 'running');
          this.els.startBtn.disabled = true;
          this.els.pauseBtn.disabled = false;
          this.els.roundBtn.disabled = false;
          this.els.toggleWorkoutViewBtn.style.display = 'inline-block';
          this.openWorkoutView();
        });
      },

      pause() {
        if (!this.running || this.paused) return;
        this.paused = true;
        this.pauseTime = performance.now();
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) { clearInterval(this.prepInterval); this.prepInterval = null; }
        this.setStatus('paused', 'paused');
        releaseWakeLock();
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = false;
        this.els.roundBtn.disabled = true;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },
      
      async resume() {
        if (!this.running || !this.paused) return;
        await ensureAudioContext();
        await requestWakeLock();
        this.paused = false;
        this.pausedDuration += performance.now() - this.pauseTime;
        this.animationFrameId = requestAnimationFrame(() => this.tick());
        this.setStatus('training', 'running');
        this.els.pauseBtn.disabled = false;
        this.els.resumeBtn.disabled = true;
        this.els.roundBtn.disabled = false;
        if (this.workoutViewActive) {
            this.updateWorkoutView();
        }
      },

      addRound() {
        if (!this.running || this.paused) return;
        this.rounds++;
        this.updateUI();
        beepShort();
      },
      
      resetAll() {
        this.closeWorkoutView();
        this.running = false; this.paused = false; this.inPrep = false;
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        if (this.prepInterval) clearInterval(this.prepInterval);
        releaseWakeLock();
        this.remainingTime = this.duration; 
        this.rounds = 0; 
        this.pausedDuration = 0;
        this.lastAnnouncedSecond = null;
        this.midpointAnnounced = false;
        this.els.prep.style.display = 'none'; 
        this.els.timer.style.display = 'block';
        this.setStatus('ready', 'idle');
        this.els.startBtn.disabled = false;
        this.els.pauseBtn.disabled = true;
        this.els.resumeBtn.disabled = true;
        this.els.roundBtn.disabled = true;
        this.els.toggleWorkoutViewBtn.style.display = 'none';
        this.updateUI();
      },
      
      startPreparation(prepEl, timerEl, nextAction) {
        this.inPrep = true;
        prepEl.style.display = 'block';
        timerEl.style.display = 'none';
        this.setStatus('preparing', 'ready');
        let prep = 5;
        prepEl.textContent = prep;
        beepPrep();
        if (this.prepInterval) clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
          prep--;
          if (prep <= 0) {
            clearInterval(this.prepInterval); this.prepInterval = null;
            ring();
            setTimeout(() => {
              this.inPrep = false;
              prepEl.style.display = 'none';
              timerEl.style.display = 'block';
              nextAction();
            }, 250);
          } else {
            prepEl.textContent = prep;
            beepPrep();
          }
        }, 1000);
      },
      
      tick() {
        if (!this.running || this.paused) return;
        const elapsedTime = performance.now() - this.startTime - this.pausedDuration;
        this.remainingTime = this.duration - elapsedTime;
        
        if (this.remainingTime <= 0) {
          this.remainingTime = 0;
          this.updateUI();
          this.completeWorkout();
          return;
        }

        if (!this.midpointAnnounced && elapsedTime >= (this.duration / 2)) {
            ring();
            this.midpointAnnounced = true;
        }

        const secondsRemaining = Math.ceil(this.remainingTime / 1000);
        if (secondsRemaining <= 5 && secondsRemaining > 0) {
          if (this.lastAnnouncedSecond !== secondsRemaining) {
            beepShort();
            this.lastAnnouncedSecond = secondsRemaining;
          }
        }

        this.updateUI();
        this.animationFrameId = requestAnimationFrame(() => this.tick());
      },
      
      completeWorkout() {
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        releaseWakeLock();
        this.setStatus('workout_complete_status', 'completed');
        victoryBells();
        this.saveWorkout({ rounds: this.rounds, duration: this.duration });
        this.closeWorkoutView();
        setTimeout(() => this.els.notesModal.classList.add('active'), 1000);
      },

      openWorkoutView() {
        this.workoutViewActive = true;
        document.getElementById('workoutStatus').style.display = 'none';
        document.getElementById('workoutLapsList').parentElement.style.display = 'none';
        this.els.workoutLapBtn.style.display = 'inline-block';
        this.els.workoutProgress.style.display = 'block';
        this.els.workoutTimer.classList.add('fortime');
        this.els.workoutTimer.style.fontFamily = 'monospace';
        
        this.els.workoutView.classList.add('active');
        document.body.style.overflow = 'hidden';
        this.updateWorkoutView();
      },

      closeWorkoutView() {
        this.workoutViewActive = false;
        this.els.workoutView.classList.remove('active');
        document.body.style.overflow = '';
      },

      updateWorkoutView() {
        if (!this.workoutViewActive) return;
        
        this.els.workoutTimer.textContent = this.formatTime(this.remainingTime);
        this.els.workoutProgress.textContent = `${t('completed_rounds')} ${this.rounds}`;
        
        if (this.paused) {
          this.els.workoutPauseBtn.textContent = t('resume');
          this.els.workoutPauseBtn.className = 'workout-btn resume';
        } else {
          this.els.workoutPauseBtn.textContent = t('pause');
          this.els.workoutPauseBtn.className = 'workout-btn pause';
        }
        
        this.els.workoutLapBtn.textContent = t('round');
        this.els.workoutPauseBtn.disabled = !this.running;
        this.els.workoutLapBtn.disabled = !this.running || this.paused;
      },

      handleWorkoutPause() {
        if (!this.running) return;
        if (this.paused) {
          this.resumeWithPrep(this.els.workoutPrep, this.els.workoutTimer);
        } else {
          this.pause();
        }
      },

      resumeWithPrep(prepEl, timerEl) {
        this.startPreparation(prepEl, timerEl, () => this.resume());
      },
      
      // Presets
      getPresets() { return JSON.parse(localStorage.getItem('amrap_presets') || '[]'); },
      savePresets(presets) { localStorage.setItem('amrap_presets', JSON.stringify(presets)); },
      renderPresets() {
        const presets = this.getPresets();
        this.els.presetsContainer.innerHTML = '';
        presets.forEach((preset, index) => {
          const btn = document.createElement('button');
          btn.className = 'preset-btn';
          btn.dataset.action = 'apply-preset';
          btn.dataset.index = index;
          btn.innerHTML = `${preset.name} <button class="preset-delete" data-action="delete-preset" data-index="${index}">×</button>`;
          this.els.presetsContainer.appendChild(btn);
        });
        this.loadPresetsList();
      },
      applyPreset(index) {
          const presets = this.getPresets();
          if (!presets[index]) return;
          const preset = presets[index];
          this.applyDuration(preset.duration);
      },
      deletePreset(index) {
          let presets = this.getPresets();
          presets.splice(index, 1);
          this.savePresets(presets);
          this.renderPresets();
      },
      loadPresetsList() {
        const presets = this.getPresets();
        if (presets.length === 0) {
          this.els.presetsList.innerHTML = `<div class="empty-history">${t('no_presets_amrap')}</div>`;
          return;
        }
        this.els.presetsList.innerHTML = presets.map((p, i) => `
          <div class="history-item">
            <div class="history-performance">${p.name}</div>
            <div class="history-details">${t('workout_duration')} ${p.duration} min</div>
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-preset" data-index="${i}">${t('edit')}</button>
              <button class="history-btn delete" data-action="delete-preset" data-index="${i}">${t('delete')}</button>
            </div>
          </div>`).join('');
      },
      openPresetModal(index = -1) {
        this.editingPresetIndex = index;
        const presets = this.getPresets();
        if (index > -1 && presets[index]) {
          const p = presets[index];
          this.els.presetModalTitle.textContent = t('edit_preset_title_amrap');
          this.els.presetName.value = p.name;
          this.els.presetDuration.value = p.duration;
        } else {
          this.els.presetModalTitle.textContent = t('new_preset_title_amrap');
          this.els.presetName.value = '';
          this.els.presetDuration.value = this.duration / 60000;
        }
        this.els.presetModal.classList.add('active');
      },
      savePreset() {
        const name = this.els.presetName.value.trim();
        const duration = this.els.presetDuration.value ? parseInt(this.els.presetDuration.value) : null;
        if (!name || !duration || duration <= 0) { alert(t('alert_fill_fields')); return; }
        
        const presets = this.getPresets();
        const newPreset = { name, duration };

        if (this.editingPresetIndex > -1) {
          presets[this.editingPresetIndex] = newPreset;
        } else {
          presets.push(newPreset);
        }
        this.savePresets(presets);
        this.renderPresets();
        this.closeAllModals();
      },
      
      // History
      getHistory() { return JSON.parse(localStorage.getItem('amrap_history') || '[]'); },
      saveHistory(history) { localStorage.setItem('amrap_history', JSON.stringify(history)); },
      loadHistory() {
        const history = this.getHistory();
        this.els.totalWorkouts.textContent = history.length;
        this.els.totalRounds.textContent = history.reduce((sum, w) => sum + (w.rounds || 0), 0);
        if (history.length === 0) {
          this.els.historyList.innerHTML = `<div class="empty-history">${t('no_history_amrap')}</div>`;
          return;
        }
        this.els.historyList.innerHTML = history.map(w => {
          const date = new Date(w.date);
          return `
          <div class="history-item">
            <div class="history-date">${date.toLocaleDateString()} • ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="history-performance">${w.rounds} Rounds</div>
            <div class="history-details">${w.duration / 60000}min AMRAP</div>
            ${w.notes ? `<div class="history-notes">"${w.notes}"</div>` : ''}
            <div class="history-actions">
              <button class="history-btn edit" data-action="edit-history" data-id="${w.id}">${t('edit')}</button>
              <button class="history-btn share" data-action="share-history" data-id="${w.id}">${t('share')}</button>
              <button class="history-btn delete" data-action="delete-history" data-id="${w.id}">${t('delete')}</button>
            </div>
          </div>`;
        }).join('');
      },
      exportHistory() {
        const history = this.getHistory();
        if (history.length === 0) return;
        const head = ['date', 'durationMinutes', 'completedRounds', 'notes'];
        const rows = history.map(w => [
          new Date(w.date).toISOString(),
          w.duration / 60000,
          w.rounds,
          (w.notes || '').replace(/[,\n"]/g, ' ')
        ]);
        const csv = [head.join(','), ...rows.map(r => r.join(','))].join('\n');
        downloadCSV(csv, 'amrap_history.csv');
      },
      clearHistory() {
        if (confirm(t('confirm_clear_history'))) {
          this.saveHistory([]);
          this.loadHistory();
        }
      },
      saveWorkout(data, notes = '') {
        const workout = { id: Date.now(), date: new Date().toISOString(), ...data, notes };
        let history = this.getHistory();
        history.unshift(workout);
        if (history.length > 50) history.pop();
        this.saveHistory(history);
        this.currentWorkout = workout;
        this.loadHistory();
      },
      updateWorkoutNotes(id, notes) {
        let history = this.getHistory();
        const workout = history.find(w => w.id === id);
        if (workout) {
          workout.notes = notes;
          this.saveHistory(history);
          this.loadHistory();
        }
      },
      deleteWorkout(id) {
          let history = this.getHistory();
          history = history.filter(w => w.id !== id);
          this.saveHistory(history);
          this.loadHistory();
      },
      
      // Modals
      closeAllModals() {
        document.querySelectorAll('#amrap_presetModal, #amrap_notesModal, #amrap_completionModal').forEach(m => m.classList.remove('active'));
      },
      handleSkipNotes() {
        this.closeAllModals();
        if (this.currentWorkout) this.showCompletionModal();
      },
      handleSaveNotes() {
        const notes = this.els.workoutNotes.value.trim();
        const workoutId = parseInt(this.els.notesModal.getAttribute('data-workout-id'));
        if (workoutId) {
          this.updateWorkoutNotes(workoutId, notes);
        } else if (this.currentWorkout) {
          this.updateWorkoutNotes(this.currentWorkout.id, notes);
          this.currentWorkout.notes = notes;
        }
        this.closeAllModals();
        if (this.currentWorkout && !workoutId) {
          this.showCompletionModal();
        }
      },
      openNotesModal(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          this.els.workoutNotes.value = workout.notes || '';
          this.els.notesModal.setAttribute('data-workout-id', id);
          this.els.notesModal.classList.add('active');
      },
      showCompletionModal() {
        if (!this.currentWorkout) return;
        this.els.completionStats.innerHTML = `
          <div class="completion-stat"><strong>${t('completed_rounds')}:</strong> ${this.currentWorkout.rounds}</div>
          <div class="completion-stat"><strong>${t('workout_duration')}:</strong> ${this.currentWorkout.duration/60000} min</div>
          `;
        this.els.completionModal.classList.add('active');
      },
      openNotesFromCompletion() {
        this.closeAllModals();
        this.els.workoutNotes.value = this.currentWorkout?.notes || '';
        this.els.notesModal.setAttribute('data-workout-id', this.currentWorkout.id);
        this.els.notesModal.classList.add('active');
      },
      shareResult() {
        if (!this.currentWorkout) return;
        this.shareWorkout(this.currentWorkout.id);
      },
      shareWorkout(id) {
          const workout = this.getHistory().find(w => w.id === id);
          if (!workout) return;
          const date = new Date(workout.date).toLocaleDateString();
          const notesText = workout.notes ? `\n\nNotes: ${workout.notes}` : '';
          const text = t('share_text_amrap', {
            rounds: workout.rounds,
            duration: workout.duration / 60000,
            date: date,
            notes: notesText
          });
          if (navigator.share) {
            navigator.share({ title: t('share_title_amrap'), text });
          } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert(t('alert_copied')));
          }
      },
    };


    // === GLOBAL INITIALIZATION ===
    document.addEventListener('DOMContentLoaded', () => {
      // Settings Listeners
      document.getElementById('languageSelect').addEventListener('change', function() {
        currentLanguage = this.value;
        localStorage.setItem('timer_pro_language', currentLanguage);
        updateAllAppsLanguage();
      });
      document.getElementById('themeSelect').addEventListener('change', function() {
        document.documentElement.setAttribute('data-theme', this.value === 'light' ? 'light' : null);
        localStorage.setItem('timer_pro_theme', this.value);
      });
      document.getElementById('volumeSlider').addEventListener('input', function() {
        ensureAudioContext().then(() => {
            if (masterGain) {
                masterGain.gain.value = this.value;
            }
        });
        localStorage.setItem('timer_pro_volume', this.value);
      });
      document.getElementById('wakeLockToggle').addEventListener('click', function() {
        this.classList.toggle('active');
        localStorage.setItem('timer_pro_wakeLock', this.classList.contains('active'));
      });

      // Load settings
      const savedLang = localStorage.getItem('timer_pro_language') || navigator.language.split('-')[0];
      if (translations[savedLang]) {
          currentLanguage = savedLang;
      }
      document.getElementById('languageSelect').value = currentLanguage;
      
      const savedTheme = localStorage.getItem('timer_pro_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme === 'light' ? 'light' : null);
      document.getElementById('themeSelect').value = savedTheme;
      
      const savedVolume = localStorage.getItem('timer_pro_volume');
      document.getElementById('volumeSlider').value = savedVolume !== null ? parseFloat(savedVolume) : 0.8;
      
      const wakeLockEnabled = localStorage.getItem('timer_pro_wakeLock') !== 'false';
      document.getElementById('wakeLockToggle').classList.toggle('active', wakeLockEnabled);
      
      // Initialize
      updateAllAppsLanguage();
      showPage('home');

      // Add a listener to release wake lock when page is not visible
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          releaseWakeLock();
        } else if (document.visibilityState === 'visible' && 
                  (EmomApp.running && !EmomApp.paused || 
                   TabataApp.running && !TabataApp.paused || 
                   ForTimeApp.running && !ForTimeApp.paused ||
                   AmrapApp.running && !AmrapApp.paused)) {
          requestWakeLock();
        }
      });
    });
  